<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>3. Rich Client (Server) Anwendung</title>

    <link rel="stylesheet" href="/dist/reset.css">
    <link rel="stylesheet" href="/dist/reveal.css">
    <link rel="stylesheet" href="/dist/theme/white.css">

    <link rel="stylesheet" href="/node_modules/highlight.js/styles/stackoverflow-dark.css">
    <link rel="stylesheet" href="/src/custom_styles/global_styles.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h4>Was beim letzten mal geschah</h4>
            <ul>
                <li>Multi Page Application</li>
                <li>JSF</li>
                <li>Wiederholung MVC</li>
            </ul>
        </section>
        <section>
            <h3>Rich Client: Client Anwendung</h3>
        </section>
        <section>
            <h4>In dieser Vorlesung</h4>
            <ul>
                <li>Single Page Applications
                    <ul>
                        <li>Was ist eine SPA?</li>
                        <li>Was sind Vorteile?</li>
                        <li>Was sind Nachteile?</li>
                    </ul>
                </li>
                <li>Frontend Architekturen: Wie baue ich eine SPA?
                    <ul>
                        <li>Component Architektur</li>
                        <li>Micro Frontends</li>
                    </ul>
                </li>
                <li>Frontend Architektur in Angular</li>
                <li>Vergleich zu anderen Frameworks (React, Vue, Flutter)</li>
                <li>Praxis: Bau unserer Todo Anwendung in Angular</li>
            </ul>
        </section>
        <section>
            <h4>Wiederholung</h4>
            <p>Wie funktioniert die Navigation bei Multi Page Anwendungen?</p>
            <pre>
        <code class="language-plantuml">
          @startuml
          activate Client
          Client -> Server: Request (GET)
          deactivate Client
          activate Server
          Server -> Client: Response (HTML Page)
          deactivate Server
          activate Client
          Client -> Server: Request (Post)
          deactivate Client
          activate Server
          Server -> Client: Response (HTML Page)
          deactivate Server
          activate Client
          @enduml
        </code>
      </pre>
        </section>
        <section>
            <section>
                <h3>Motivation</h3>
            </section>
            <section>
                <h4>Daten vom Backend</h4>
                <pre>
        <code class="language-html" data-line-numbers>&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
    &lt;script&gt;{javascript}&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
      </pre>
            </section>
            <section>
                <h4>Stylesheets</h4>
                <pre>
        <code class="language-html" data-line-numbers="3">&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
    &lt;script&gt;{javascript}&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
      </pre>
            </section>
            <section>
                <h4>Stylesheets</h4>
                <ul>
                    <li>enthalten häufig ähnliche Informationen</li>
                    <li>könnten einmalig ausgeliefert werden</li>
                </ul>
                <pre>
          <code class="language-html" data-line-numbers>&lt;style&gt;
 label {
   font-size: 12pt;
   color: blue;
 }

 input {
   font-size: 10pt;
   color: green;
   height: 10px;
   width: 20px;
 }
&lt;/style&gt;
          </code>
        </pre>
            </section>
            <section>
                <h4>JavaScript</h4>
                <pre>
        <code class="language-html" data-line-numbers="4">&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
    &lt;script&gt;{javascript}&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
      </pre>
            </section>
            <section>
                <h4>JavaScript</h4>
                <ul>
                    <li>ebenfalls repetitiv</li>
                    <li>auf mehreren HTML Seiten braucht es gleiche Funktionalität</li>
                </ul>
                <pre>
          <code class="language-html" data-line-numbers>&lt;script&gt;
  function openDropdown() {
    // do it
  }

  function doSomeFancyAnimation() {
    // do it
  }
&lt;/script&gt;
          </code>
        </pre>
            </section>
            <section>
                <h4>HTML Struktur</h4>
                <pre>
        <code class="language-html" data-line-numbers>&lt;html&gt;
  // head
  &lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
    &lt;footer&gt;&lt;/footer&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
        </pre>
            </section>
            <section>
                <h4>HTML Struktur</h4>
                <ul>
                    <li>dynamischer Anteil der Seite beschränkt sich auf Informationen</li>
                </ul>
                <pre>
        <code class="language-html" data-line-numbers="7">&lt;html&gt;
  // head
  &lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
    &lt;footer&gt;&lt;/footer&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
        </pre>
            </section>
            <section>
                <h4>Wartezeiten nach den Requests</h4>
                <pre>
                    <code class="language-plantuml">
                        @startuml
                        activate Client
                        Client -> Server: Request (GET)
                        deactivate Client
                        activate Server
                        Server -> Server: führt Geschäftslogik aus
                        Server -> Client: Response (HTML Page)
                        deactivate Server
                        activate Client
                        Client -> Server: Request (Post)
                        deactivate Client
                        activate Server
                        Server -> Server: führt Geschäftslogik aus
                        Server -> Client: Response (HTML Page)
                        deactivate Server
                        activate Client
                        @enduml
                    </code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>User können in den Wartezeiten, bis die nächste Seite geladen wurde, nichts machen.</li>
                        <li>Es wird außerdem kein Loadingspinner etc. angezeigt</li>
                        <li>Bei SPA's wäre dies möglich</li>
                    </ul>
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Single Page Application</h3>
            </section>
            <section>
                <p><em>“A single-page application is exactly what its name implies: a JavaScript-driven web application that requires only a single page load.”</em></p>
                <p class="cite">JavaScript - The Definitive Guide</p>
                <p class="cite">5th ed., O'Reilly, Sebastopol, CA, 2006</p>
            </section>
            <section>
                <h4>Single Page Application Konzept</h4>
                <pre>
                    <code class="language-plantuml">
                        @startuml
                        participant "Client" as client
                        participant "Web Server" as webServer
                        participant "Web Service" as webService

                        group Initializing
                        activate client
                        client -> webServer: GET /index.html
                        activate webServer
                        webServer -> client: index.html
                        webServer -> client: styles.css
                        webServer -> client: script.js
                        deactivate webServer
                        client -> client: start application
                        end

                        group Runtime
                        client -> webService: GET /some-id
                        deactivate client
                        activate webService
                        webService -> client: some-data
                        deactivate webService
                        activate client
                        client -> client: rerender
                        end
                        @enduml
                    </code>
                </pre>
            </section>
            <section>
                <h4>Vorteile einer SPA</h4>
                <ul>
                    <li>reduktion der übertragenen Daten</li>
                    <li>bessere User Experience</li>
                    <li>weniger Serverressourcen</li>
                    <li>Session Clientseitig (Server ist Stateless)</li>
                    <li>Hybride Anwendung auch mobile einsetzbar</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>SPA's verhalten sich häufig wie App's. Daher können hybride Anwendungen auch als App eingesetzt werden.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Reduktion der übertragenen Daten</h4>
                <p>hier reden wir von Daten zur "Runtime"</p>
                <pre>
        <code class="language-html" data-line-numbers="7">&lt;html&gt;
  // head
  &lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;div&gt;
      // some data
    &lt;/div&gt;
    &lt;footer&gt;&lt;/footer&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
        </pre>
                <aside class="notes">
                    <ul>
                        <li>Erinnerung an das UML Initializing vs Runtime</li>
                        <li>Erinnerung, dass nur noch Daten übertragen werden, keine ganzen HTML Seiten</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Bessere User Experience</h4>
                <ul>
                    <li>kürzere Response Time</li>
                    <li>weniger BE Request notwendig</li>
                    <li>Seite ist während eines BE Requests benutzbar</li>
                    <li>asynchrones Nachladen der Daten</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Kürzere Response Time
                            <ul>
                                <li>durch weniger Daten die übertragen werden müssen</li>
                            </ul>
                        </li>
                        <li>weniger BE Requests notwendig
                            <ul>
                                <li>Fehlermeldungen etc. können bereits ohne BE Requests angezeigt werden</li>
                                <li>Auch Geschäftslogik kann direkt im Frontend ausgeführt werden</li>
                            </ul>
                        </li>
                        <li>Seite ist während eines BE Requests benutzbar
                            <ul>
                                <li>Durch Loadingspinner etc. bekommt der Nutzer ein direktes Feedback auf seine Action</li>
                                <li>Nutzer fordert Daten an und kann sich dann mit etwas anderem beschäftigen, bis die Daten geladen sind.</li>
                            </ul>
                        </li>
                        <li>asynchrones Nachladen der Daten
                            <ul>
                                <li>der Nutzer kann bereits mit ersten Daten interagieren, während andere noch geladen werden.</li>
                            </ul>
                        </li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Weniger Serverressourcen</h4>
                <ul>
                    <li>Rendering läuft auf dem Client</li>
                    <li>Geschäftslogik kann auf dem Client laufen
                        <ul>
                            <li>weniger BE Requests notwendig</li>
                        </ul>
                    </li>
                    <li>Server kümmert sich nur um die Daten</li>
                </ul>
            </section>
            <section>
                <h4>Nachteile einer SPA</h4>
                <ul>
                    <li>initiale Response ist groß</li>
                    <li>Client ist nicht Vertrauenswürdig</li>
                    <li>duplizierter Code</li>
                    <li>höherer Entwicklungsaufwand</li>
                </ul>
            </section>
            <section>
                <h4>Initiale Response ist groß</h4>
                <pre>
                    <code class="language-plantuml">
                        @startuml
                        participant "Client" as client
                        participant "Web Server" as webServer

                        group Initializing
                        activate client
                        client -> webServer: GET /index.html
                        activate webServer
                        webServer -> client: index.html
                        webServer -> client: styles.css
                        webServer -> client: script.js
                        deactivate webServer
                        client -> client: start application
                        end
                        @enduml
                    </code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Wir erinnern uns an das SPA Laufzeitdiagramm</li>
                        <li>zu Anfang müssen erstmal alle Daten geladen werden</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Client ist nicht Vertrauenswürdig</h4>
                <ul>
                    <li>JavaScript Code auf dem Client kann manipuliert werden</li>
                    <li>erneute Validierung im BE notwendig</li>
                    <li>Validierungen sind meist duplizierter Code</li>
                    <li>hierfür gibt es Abhilfe:
                        <ul>
                            <li>Multiplattform Libraries</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>ein versierter Nutzer kann den JavaScript Code in seinem Browser verändern.
                            <ul>
                                <li>wir sprechen hier noch nicht mal von XSS</li>
                            </ul>
                        </li>
                        <li>Daten die im BE gespeichert werden, müssen daher noch mal validiert werden</li>
                        <li>Validierungen, aber auch andere Geschäftslogik sind häufig dupliziert.
                            <ul>
                                <li>Das kann gewünscht sein. Vielleicht möchte man Frontend und Backend voneinander entkoppeln</li>
                                <li>Andererseits kann man Code auch übers BE und Frontend sharen.</li>
                                <li>Multiplattform Libraries wie von Kotlin können hier helfen</li>
                            </ul>
                        </li>
                    </ul>
                </aside>
            </section>
        </section>
        <section>
            <h4>Single Page Applications</h4>
            <ul>
                <li>Wir haben besprochen:
                    <ul>
                        <li>Was ist eine SPA?</li>
                        <li>Was sind ihre Vorteile?</li>
                        <li>Was sind ihre Nachteile?</li>
                    </ul>
                </li>
                <li>Was uns fehlt:
                    <ul>
                        <li>Wie baut man eine SPA?</li>
                        <li>Welche Architekturen gibt es?</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section>
            <h3>Wie baut man eine SPA?</h3>
        </section>
        <section>
            <section>
                <h3>Einfach mal loslegen?</h3>
            </section>
            <section>
                <h4>Einfach mal loslegen?</h4>
                <ul>
                    <li>Erster Gedanke: Einfach mal loslegen.</li>
                    <li>Wie soll die UI aussehen?</li>
                    <li>Welche HTML Elemente brauche ich?</li>
                    <li>Was brauche ich fürs Styling?</li>
                    <li>Welche Logik soll das Frontend unterstützen?</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Vielleicht denken sie hier noch an die Trennung von HTML, CSS und JavaScript.</li>
                        <li>Damit wird das ganze dann ein wenig schöner.</li>
                        <li>Trotzdem wird es wahrscheinlich damit Enden, dass man einen Monolith erhält.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Monolith</h4>
                <img src="assets/monolith.jpg" style="height: 400px;">
                <aside class="notes">
                    <ul>
                        <li>Sieht für sie jetzt evtl. schön aus.</li>
                        <li>Aber versuche sie mal diese Anwendung wiederzuverwenden oder sogar für neue Features zu erweitern.</li>
                        <li>Das ist meistens das Problem bei monolithischen Anwendungen.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Monolith</h4>
                <ul>
                    <li>Monolithen sind typischerweise:
                        <ul>
                            <li>schwer wiederverwendbar</li>
                            <li>schwer erweiterbar</li>
                        </ul>
                    </li>
                    <li>Monolithen haben in sich meist:
                        <ul>
                            <li>keine klaren Schnittstellen</li>
                            <li>viele Abhängigkeiten</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h4>Monolith</h4>
                <ul>
                    <li>grundlegend sind Monolithen nicht schlecht um erstmal loszulegen</li>
                    <li>ein Monolith kann durchaus seine Berechtigung haben</li>
                    <li>wenn die Codebasis wächst werden diese leider sehr unübersichtlich</li>
                    <li>mit mehreren Teams an einem Monolith zu arbeiten sorgt häufig für Konflikte</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Monolithen sind nicht grundsätzlich schlecht</li>
                        <lI>Ein gut designter Monolith kann zu einem Modulith werden und sehr gut funktionieren</lI>
                    </ul>
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Component Architecture</h3>
                <img src="assets/error-lego.jpg" style="height: 400px;">
                <aside class="notes">
                    <ul>
                        <li>Component Architecture könnte man sich wie Lego vorstellen</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Architecture</h4>
                <ul>
                    <li>divide et impera
                        <ul>
                            <li>teilen der Webseite in einzelnen Components</li>
                            <li>Verteilung und Strukturierung der Komplexität</li>
                        </ul>
                    </li>
                    <li>Components
                        <ul>
                            <li>enthalten zusammengehörige Funktionalität
                                <ul>
                                    <li>quasi wie Klassen in OOP</li>
                                </ul>
                            </li>
                            <li>haben feste Schnittstellen
                                <ul>
                                    <li>möglichst lose Kopplung und hohe Kohäsion</li>
                                    <li>analog wie Legosteine</li>
                                </ul>
                            </li>
                            <li>abstrahieren Struktur und Styling</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>divide et impera: steht natürlich nur auf der Folien, weil lateinische Wörter Klug aussehen</li>
                        <li>Die Idee ist aber grundlegend seine Webseite in einzelne Components aufzuteilen.</li>
                        <li>Damit teilt man die Komplexität seiner Seite in kleinere Teile (Components).</li>
                        <li>Quasi wie man es aus dem klassischen Softwareengineering kennt. Dort wird auch funktionalität die zusammengehört in Klassen zusammengefasst.</li>
                        <li>Über Schnittstellen (vergleich zu Lego die Noppen), können Components dann wieder zusammengesteckt werden.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Architecture</h4>
                <img src="assets/lego-component-example.jpg" style="height: 400px;">
            </section>
            <section>
                <h4>Component Architecture</h4>
                <ul>
                    <li>SRP: Single Responsible Principle</li>
                    <li><em>"A class should have only one reason to change."</em></li>
                    <li><em>"A module should be responsible to one, and only one, actor."</em></li>
                    <li>dies ist auch auf Components anwendbar</li>
                    <li>Components sollten
                        <ul>
                            <li>nur einen Grund haben sich zu ändern</li>
                            <li>nur einem Akteur gegenüber verantwortlich sein</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Zitate von Robert C. Marting SOLID und Clean Architecture</li>
                        <li>Man könnte sich denken, dass dies nur bei kleineren Components möglich ist</li>
                        <li>Doch auch eine Page hat eine Verantwortlichkeit und damit nur einen Grund sich zu ändern</li>
                        <li>Bzw. sie ist gegenüber einem Akteur verantwortlich</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Architecture</h4>
                <ul>
                    <li>Was könnte man sich alles als Component vorstellen?
                        <ul>
                            <li>Buttons, Text Fields, Labels, etc.</li>
                            <li>Search Bar, Form Groups, Cards, etc.</li>
                            <li>Header, Footer, Overlays, etc.</li>
                            <li>Pages</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Unter einer Card kann man sich gebündelten Content vorstellen. Möglicherweise mit Bild und Edit Button oder so?</li>
                        <li>Eine Component kann also ein sehr kleiner Teil der Anwendung sein, wie z.B. ein einzelner Button</li>
                        <li>Eine Component kann aber auch ein Abschnitt sein oder sogar eine ganze Seite, die sich mit einem bestimmten Thema beschäftigt.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Components</h4>
                <pre>
                    <code class="language-html" data-line-numbers>&lt;button value=&quot;Submit&quot; onclick=&quot;alert(&#39;Button clicked!&#39;)&quot;/&gt</code>
                </pre>
                <ul>
                    <li>Components haben wie Classes feste Schnittstellen</li>
                    <li>damit können sie modular eingesetzt werden</li>
                    <li>normalerweise gibt es Input und Output Parameter</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>normalerweise gibt man etwas in eine Component hinein und bekommt etwas aus der Component zurück</li>
                        <li>wir setzen mit der Component Architecture auf klassischen HTML Elementen auf und bauen daraus größere Components</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Components</h4>
                <p>Beispiel (Angular):</p>
                <pre>
                  <code class="javascript" data-line-numbers>export class TextInputComponent {

    @Input()
    placeholder: string;
    @Output()
    text: EventEmitter&lt;string&gt;;

    someLogic() {
        // some logic
    }
}                   </code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Jetzt fragen sie sich vielleicht, warum sollte ich eine TextInputComponent selbst bauen? Die gibts doch schon in HTML?</li>
                        <li>Components abstrahieren nicht nur Struktur (HTML) sondern liefern gleich auch das Styling mit.</li>
                        <li>der Aufrufer einer Component soll lediglich Input und Output mitgeben und sich um Struktur und Styling keine Gedanken machen müssen.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Aufbau einer Component Architecture</h4>
                <p>meist nach dem MVC Pattern</p>
                <img src="assets/MVC.png" style="height: 400px">
                <aside class="notes">
                    <ul>
                        <li>um dies besser zu verstehen schauen wir uns dies anhand eines Angular Beispiels an</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Aufbau einer Component: Beispiel</h4>
                <aside class="notes">
                    <ul>
                        <li>grundsätzlich besteht eine Component aus getrenntem Typescript, HTML und CSS</li>
                        <li>die Trennung macht eine Component in sich übersichtlich</li>
                        <li>es empfiehlt sich möglichst wenig Logik im HTML zu hinterlassen, dafür ist das Typescript File</li>
                        <li>der View ist damit also klar. Das ist das HTML.</li>
                        <li>als Model werden normalerweise Services in Angular betrachtet</li>
                        <li>Services sind reiner Typescriptcode. Es handelt sich hierbei wieder um Komponenten in denen nur Logik oder Backendaufrufe stattfinden.</li>
                        <li>Sie stellen also die Daten bereit, die in der View angezeigt werden können</li>
                        <li>Als Controller kann man sich damit den Typescript Part der Component vorstellen.</li>
                        <li>Oft wird das Angular Component System nicht mit MVC, sondern MVVM bezeichnet. Model View ViewModel.</li>
                        <li>Ich denke man kann dies aber auch gut auf MVC abstrahieren.</li>
                        <li>Ich gehe später noch mal genauer auf die einzelne Syntax etc. von Angular ein, damit ihr auch ein Praxisbeispiel dazu bauen könnt.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Architecture</h4>
                <ul>
                    <li>Vorteile:
                        <ul>
                            <li>Konsistenz im Styling</li>
                            <li>Wiederverwendbarkeit</li>
                            <li>schnellere Entwicklung</li>
                            <li>einfachere Instandhaltung </li>
                        </ul>
                    </li>
                    <li>Nachteile:
                        <ul>
                            <li>tiefe Verschachtelungen möglich</li>
                            <li>Logik in den Components</li>
                            <li>im Prinzip immer noch ein Monolith (Modulith)</li>
                            <li>mehrere Teams an einem Artefakt ist nicht optimal</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <!--TODO evtl. hier noch weitere Folien hinzufügen um die Vorteile/Nachteile zu vertiefen-->
                    <ul>
                        <!--Vorteile-->
                        <li>Konsistenz
                            <ul>
                                <li>Komponenten wie Buttons gehören zu Atomen und sollten wiederverwendet werden.</li>
                                <li>Dies spart Zeit, außerdem sehen die Button überall gleich aus. Sorgt für Konsistenz im Styling</li>
                            </ul>
                        </li>
                        <li>Schnellere Entwicklung
                            <ul>
                                <li>Ich muss den Button nicht noch mal für eine andere Seite Stylen oder mit den Code dazu kopieren.</li>
                                <li>Ich kann auf bereits basierende Strukturen aufbauen.</li>
                            </ul>
                        </li>
                        <!--Nachteile-->
                        <li>tiefe Verschachtelungen
                            <ul>
                                <li>Große Seiten und Anwendungen kämpfen häufig mit einer sehr hohen Verschachtelungstiefe</li>
                                <li>Durch Komponenten die kein Styling hinzufügen, sondern nur Logik bereitstellen und teilen, wird die Wrapper Hölle noch schlimmer.</li>
                                <li>Dies ist nicht sehr übersichtlich.</li>
                            </ul>
                        </li>
                        <li>Logik in Components
                            <ul>
                                <li>View Components sollten relativ frei von Logik sein.</li>
                                <li>Logik sollte in Services oder ähnliches ausgelagert werden.</li>
                            </ul>
                        </li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Architecture Frameworks</h4>
                <ul>
                    <li>Angular</li>
                    <li>React</li>
                    <li>Vue</li>
                    <li>und viele mehr...</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>die meisten JavaScript SPA Frameworks setzen auf eine Component Architecture.</li>
                        <li>die Frameworks unterscheiden sich meistens nur in Details, Syntax, Performance.</li>
                        <li>hat man die Basis, also Component Architectures verstanden, so kann man sich leicht an neue Frameworks gewöhnen</li>
                        <li>kann man eins, kann man alle...</li>
                        <li>es gibt allerdings doch einige unterschiede, die wir uns jetzt anschauen wollen.</li>
                        <li>Dazu könnt ihr euch das mal ansehen: https://academind.com/tutorials/angular-vs-react-vs-vue-my-thoughts/</li>6
                        <li>wir schauen uns später konkret Angular an.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Angular</h4>
                <ul>
                    <li>mehr eine Plattform als ein Framework</li>
                    <li>kann einiges "out of the box"
                        <ul>
                            <li>DOM Manipulation</li>
                            <li>State Management</li>
                            <li>Routing</li>
                            <li>Form Validation</li>
                            <li>HTTP Client</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>bringt fast alles mit was man braucht</li>
                        <li>Vorteil: Versionen sind im Angular Ökosystem kompatibel</li>
                        <li>kann jedoch trotzdem um Libraries erweitert werden</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>React</h4>
                <ul>
                    <li>sehr leichtgewichtig</li>
                    <li>reduziert auf
                        <ul>
                            <li>DOM Manipulation</li>
                            <li>State Management</li>
                        </ul>
                    </li>
                    <li>nur die Basis für die Component Architecture</li>
                    <li>erweiterbar über Libraries</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>sehr leichtgewichtig</li>
                        <li>Libraries durch eine große Community</li>
                        <li>Versionsproblematik mit externen Libraries</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Vue</h4>
                <ul>
                    <li>liegt zwischen Angular und React</li>
                    <li>bietet
                        <ul>
                            <li>DOM Manipulation</li>
                            <li>Sate Management</li>
                            <li>Routing</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h3>Exkurs: Atomic Design</h3>
            </section>
            <section>
                <h4>Exkurs: Atomic Design</h4>
                <p>große Frontends mit vielen Components werden unübersichtlich</p>
                <img src="assets/lego-unsortiert.jpg" style="height: 400px;">
            </section>
            <section>
                <h4>Exkurs: Atomic Design</h4>
                <p>Strukturierung und Kategorisierung von Components</p>
                <p>Ziel ist ein ordentlicher Baukasten an Components</p>
                <img src="assets/component-periodic-table.png" style="height: 400px;">
                <p class="small-text">https://bradfrost.com/blog/post/atomic-web-design/</p>
            </section>
            <section>
                <h4>Exkurs: Atomic Design</h4>
                <ul>
                    <li>nach Atomic Design werden Components geordnet nach:
                        <ul>
                            <li>Atoms - Buttons, Text Fields, etc.</li>
                            <li>Molecules - Search Bar, Form Groups, etc.</li>
                            <li>Organisms - Header, Footer, Overlays, etc.</li>
                            <li>Templates - Schablone</li>
                            <li>Pages - konkrete Seite</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>https://bradfrost.com/blog/post/atomic-web-design/</li>
                        <li>Atoms - die Bausteine unserer Anwendung - Buttons, etc.</li>
                        <li>Molecules - kleine zusammenschlüsse von Atoms - Suchfelder, Form Groups</li>
                        <li>Organisms - fachliche Components. Zusammenschlüsse von Molecules mit denen der User interagieren kann</li>
                        <li>Templates - Schablone die den Aufbau der Seite zeigt</li>
                        <li>Pages - konkrete Seiten</li>
                    </ul>
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Ausblick: Micro Frontends</h3>
            </section>
            <section>
                Hier ein wenig Micro Frontends erklären.
            </section>
        </section>
        <section>
            <section>
                <h3>Praxis: Todo Anwendung</h3>
                <aside class="notes">
                    <ul>
                        <li>Wir haben uns jetzt grundlegende Konzepte für Frontends angesehen.</li>
                        <li>Jetzt wird es Zeit für die Praxis.</li>
                        <li>Dafür sollten wir uns noch mal die Syntax von Angular ansehen.</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>Component Syntax</h4>
                <pre>
                  <code class="javascript" data-line-numbers>@Component({
    selector: 'app-text-input',
    templateUrl: './text-input.component.html',
    styleUrls: ['./text-input.component.css'],
})
export class TextInputComponent {
      // some logic
}                   </code>
                </pre>
            </section>
        </section>
        <section>
            Was wir alles für diese Section brauchen:

            Typische Frontendarchitektur (anzeige): Component Architektur
            https://www.simform.com/blog/component-based-development/
            Kurzer Einblick in das Thema Micro Frontends
            https://martinfowler.com/articles/micro-frontends.html

            Component System Angular
            Services in Angular
            Dependency Injection in Angular

            Input/Output Params

            Routing

            Simples Beispiel bauen.

            Typische Frontendarchitektur (statehandling): StateManagement mit Redux
            Konkrete Bibliothek NgRx
            Actions
            Reducer
            State

            Unsere bestehende Anwendung um ein StateManagement erweitern.

            Vergleich zu anderen Frameworks
            React, Vue, Flutter
            Component System22
            StateManagement
                Redux, Bloc, etc.
            https://ordina-jworks.github.io/angular/2018/10/08/angular-state-management-comparison.html
        </section>
        <section>
            <h4>Beim nächsten mal:</h4>

            <li>Statemanagement im Frontend</li>
            <li>Statemanagement mit Angular NgRx</li>
            <li>Vergleich zu anderen Frameworks</li>
            <li>Praxis: Einbau eines Statemanagements in unsere Todo Anwendung mit NgRx</li>
        </section>
    </div>
</div>

<script src="/dist/reveal.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        dependencies: [
            {src: '//cdn.jsdelivr.net/npm/reveal-plantuml'},
        ]
    });
</script>
</body>
</html>
