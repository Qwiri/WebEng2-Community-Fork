<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>3. Rich Client: Server Anwendung</title>

  <link rel="stylesheet" href="/dist/reset.css">
  <link rel="stylesheet" href="/dist/reveal.css">
  <link rel="stylesheet" href="/dist/theme/white.css">

  <link rel="stylesheet" href="/node_modules/highlight.js/styles/stackoverflow-dark.css">
  <link rel="stylesheet" href="/src/custom_styles/global_styles.css">
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h3>Rich Client: Server Anwendung</h3>
    </section>
    <section>
      <section data-markdown>
        <textarea data-template>
          ### Spring
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring

          - Application Framework
          - Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring-Boot

          - Basiert auf Spring
          - Erweitert um Java EE
          - Convention-over-Configuration
          - Annotation-Base Configuration
            - Spring ursprünglich eigentlich XML
        </textarea>
        <aside class="notes">
          <ul>
            <li>Spring besteht aus Modulen die miteinander kombiniert werden können</li>
            <li>Spring Boot erweitert Spring um Java EE (Servlets)</li>
            <li>Standardkonfiguration wird bevorzugt, am besten keine komplizierte Konfiguration</li>
            <li>Abweichend davon kostet es Konfigurationsaufwand</li>
          </ul>
        </aside>
      </section>
      <!-- Spring - Bootstrap -->
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap

          - Aufbau des Objektgraphen
          - Zwei primäre Quellen für Objekte
            - Components
            - Configurations
          - Objektgraph ist normalerweise statisch
          - Objektgraph erlaubt dynamische Erweiterung
        </textarea>
        <aside class="notes">
          <ul>
            <li>Objektgraphen ist der Graph den der Dependency Injection Container aufbaut</li>
            <li>Quellen -> Einstiegspunkte für den Graphen</li>
            <li>zu jeder Zeit können Objekte zur Laufzeit hinzugefügt werden</li>
          </ul>
        </aside>
      </section>
      <section data-markdown>
        <textarea data-template>
          ### Bootstrap
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Verwendung

          - `@SpringBootApplication` zur Deklaration des Einstiegspunkt
          - `@ComponentScan` für komplexere Umstände
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Beispiel

          ```java
          @SpringBootApplication
          public class MySpringApplication {
              public static void main(String[] args) {
                  SpringApplication.run(MySpringApplication.class, args);
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Details

          `@SpringBootApplication`
          - `scanBasePackages` Base-Package für alle Configurations und Components
            - Default ist das aktuelle Package
        </textarea>
      </section>
      <!-- Spring - Components -->
      <section data-markdown>
        <textarea data-template>
          #### Components

          - Direkte Deklaration von Objekten
          - Erzeugung durch den Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Verwendung

          - `@Component` zur Deklaration
          - `@Order` zur Definition der Präzedenz
        </textarea>
        <aside class="notes">
          <ul>
            <li>@Order wird nur gebraucht wenn man bestehende Components einer Library überschreiben möchte</li>
          </ul>
        </aside>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Beispiel

          ```java
          @Component
          public class MyComponent {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Aliase

          - `@Controller` für Endpoints
          - `@RestController` für ReST-Endpoints
          - `@Services` für Services
          - `@Repository` für Datenbankschnittstellen
        </textarea>
      </section>
      <!-- Spring - Configurations -->
      <section data-markdown>
        <textarea data-template>
          #### Configurations

          - Indirekte Deklaration von Objekten
          - Sowie Ändern und Erweitern bestehender Objekte
          - Aufruf durch den Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Configurations - Verwendung

          - `@Configuration` zur Deklaration einer Konfiguration
          - `@Bean` zur Deklaration eines Objektes
          - `@Order` zur Definition der Präzedenz
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Configurations - Beispiel

          ```java
          @Configuration
          public class MyConfiguration {
              @Bean
              public MyComponent createComponent(){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <!-- Spring - Referenzierung -->
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung

          - Benötigt Aufruf durch Dependency-Injection-Container
          - Auflösung der Referenzen über Typ
          - Mehrfach vorhandene Objekt über Namen ggf. Classifier
          - Boostrap scheitert wenn Referenz nicht auslösbar
            - keine entsprechendes Objekt
            - mehrere entsprechende Objekte
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Verwendung

          - `@Autowired` zur Markierung eines Parameters
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Beispiel

          ```java
          @Component
          public class MyComponentWithDependency {
              public MyComponentWithDependency(@Autowired MyRequiredComponent component){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Beispiel

          ```java
          @Configuration
          public class MyConfiguration {
              @Bean
              public MyComponentWithDependency createDependantComponent(@Autowired MyRequiredComponent component){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Details

          `@Autowired`
          - `required` für optionale Objekte
        </textarea>
        <aside class="notes">
          <ul>
            <li>required ist ein Attribut von Autowired</li>
            <li>wird z.B. für Libraries verwendet</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section data-markdown>
        <textarea data-template>
          ### Spring Schichten
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring Schichten

          - Frontend
          - Middleware
          - Backend
        </textarea>
      </section>
      <!-- Spring - Controllers -->
      <section data-markdown>
        <textarea data-template>
          #### Controller

          - Schnittstelle zur Außenwelt
          - Abstraktes Konstrukt
          - Verschiedene Arten von Schnittstellen möglich (ReST, GraphQL etc.)
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Controller - Einordnung

          - Frontend
          - Referenziert Services
          - Wird von niemanden referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Controller - Verwendung

          - `@Controller` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller

          - Konkrete Ausprägung eines Controllers
          - ReST basiert
          - Definiert die Endpoints der Anwendung
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Verwendung

          - `@RestController` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Verwendung

          - `@RequestMapping` zur Definition des Endpoints
          - `@PathVariable` für Pfad-Variablen
          - `@QueryParam` für Query-Parameter
          - `@RequestBody` für Bodies
          - `@ResponseStatus` für besondere Http-Status
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RestController
          @RequestMapping(path = "/notes", produces = MediaType.APPLICATION_JSON)
          public class MyNoteController {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notizen holen
          `GET /notes`

          Notizen suchen
          `GET /notes?q={search}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(method = RequestMethod.GET)
          public List<Note> getNotes(@RequestParam(name = "q", required = false) String search) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz anlegen
          `POST /notes`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(method = RequestMethod.POST)
          public Note createNote(@RequestBody NoteProposal proposal) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz ändern
          `PUT /notes/{note}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(path = "/{note}", method = RequestMethod.PUT)
          public Note updateNote(@PathVariable("note) Long noteId, @RequestBody NoteProposal proposal) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz ändern
          `DELETE /notes/{note}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(path = "/{note}", method = RequestMethod.DELETE)
          public Note deleteNote(@PathVariable("note) Long noteId, @RequestBody NoteProposal proposal) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Anhang holen
          `GET /notes/{note}/attachment/{attachment}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(
              path = "/{note}/attachment/{attachment}",
              method = RequestMethod.GET,
              produces = MediaType.APPLICATION_OCTET_STREAM_VALUE
          )
          public byte[] getAttachment(@PathVariable("note") Long noteId, @PathVariable("attachment) String attachmentId) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Details

          `@RequestMapping`
          - `path` Pfad ink. Pfad-Variablen
          - `method` Erwartete Methode
          - `consumes` Erwarteter Content-Type
          - `produces` Erzeugter Content-Type
        </textarea>
      </section>
      <!-- Spring - Service -->
      <section data-markdown>
        <textarea data-template>
          #### Service

          - Implementiert Businesslogik
          - Oftmals durch ein Interface abstrahiert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Einordnung

          - Middleware
          - Referenziert Repositories und andere Services
          - Wird von Controller und Services referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Verwendung

          - `@Service` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Beispiel

          ```java
          @Service
          public interface MyNoteService {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Beispiel

          ```java
          @Service
          public class MyNoteServiceImpl implements MyNoteService {
              ...
          }
          ```
        </textarea>
      </section>
      <!-- Spring - Repository -->
      <section data-markdown>
        <textarea data-template>
          #### Repository

          - Implementiert Datenbankschnittstelle für eine Entity
          - Abstraktes Konstrukt
          - Verschiedene Arten von Datenbankschnittstelle möglich (JPA, ElasticSearch etc.)
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Repository - Einordnung

          - Backend
          - Referenziert andere Repositories
          - Wird von Services referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Repository - Verwendung

          - `@Repository` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository

          - Basiert auf Java-Persistence-API
          - Implementation per Proxy
          - Erweiterung durch Annotationen
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Verwendung

          - `@Repository` zur Deklaration
          - `@Query` zur Definition komplexer Queries
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Repository
          public interface MyNoteRepository extends JpaRepository<Note, Long> {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          List<Note> findAll();
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          Note findById(Long id);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          Note findByNameAndDescription(String name, String description);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Query("SELECT n FROM Notes n WHERE n.tag IN (:tags) AND n.creationDate >= :timestamp")
          Note findWithTagsAfter(String[] tags, OffsetDateTime timestamp);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Better Practice

          - Vielzahl an vordefinierten Operationen
          - Wrapper-Klasse für explizite Schnittstellen
          - Mehr Aufwand - Mehr Konsistenz
            - Projekt-spezifisches Wording
            - Vermeidung von `Optional`
            - Keine ungewollten Operationen
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Repository
          public class MyNoteRepository {
              private @Autowired MySpringNoteRepository delegate;

              public @Nullable Note find(@NotNull Long id) {
                  return delegate.findById(id).orElse(null)
              }
          }
          ```
        </textarea>
      </section>
    </section>
  </div>
</div>

<script src="/dist/reveal.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script>
  Reveal.initialize({
    hash: true,
    slideNumber: true,
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
    dependencies: [
      {src: '//cdn.jsdelivr.net/npm/reveal-plantuml'},
    ]
  });
</script>
</body>
</html>
