<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>3. Rich Client: Server Anwendung</title>

  <link rel="stylesheet" href="/dist/reset.css">
  <link rel="stylesheet" href="/dist/reveal.css">
  <link rel="stylesheet" href="/dist/theme/white.css">

  <link rel="stylesheet" href="/node_modules/highlight.js/styles/stackoverflow-dark.css">
  <link rel="stylesheet" href="/src/custom_styles/global_styles.css">
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h3>Rich Client: Server Anwendung</h3>
    </section>
    <section>
      <section>
        <textarea data-template>
          ### Überleitung
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Verantwortlichkeiten - JSF

          - View-Management
            - Rendering
            - Validation
          - State-Management
            - Events
            - Routing
          - Data-Management
            - Persistence
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Verantwortlichkeiten - Rich Client

          - View-Management
            - Rendering
            - Ensurance
          - State-Management
            - Events
            - Routing
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Verantwortlichkeiten - Webservice

          - Data-Management
            - Validation
            - Persistence
        </textarea>
      </section>
    </section>
    <section>
      <section>
        <textarea data-template>
          ### Webservice
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Webservice - Stateless

          - Kein Zustand
          - Keine Session
          - Anfrage ausschließlich mit fachlichen Informationen
        </textarea>
        <aside class="notes">
          <ul>
            <li>Keine Übertragung von Zustandsänderungen</li>
            <li>Keine Übertragung von unzusammenhängenden Informationen</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Webservice - Stateless

          - Keine nicht-persistenten Informationen
            - Transparentes Caching ausgenommen
          - Persistierung in Datenbank oder Dateisystem
            - Transparente Datenbank oder Dateisystem
        </textarea>
        <aside class="notes">
          <ul>
            <li>Keine anfrageübergreifende Informationen</li>
            <li>Transparente Caches agieren auf persistenten oder berechenbaren Daten</li>
            <li>Transparente Caches agieren niemals auf flüchtigen Daten</li>
            <li>Transparente Caches für persistente Daten müssen kurzlebig oder Änderungen bewusst sein</li>
            <li>Transparente Datenbanken/Dateisysteme (ver)teilen über mehrere Instanzen</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Webservice - Skalierbar

          - Abhängig von ausschließlich externen Informationen
            - Eingaben des Clients
            - Daten der Persistence
          - Instanzen sind identitätslos
          - Dynamisches hoch-/runterfahren von Instanzen
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Webservice - Untrusting

          - Validierung aller Eingaben
          - Isolierung aller Eingaben
          - Durchgehende Prüfung der Authorisierung
        </textarea>
        <aside class="notes">
          <ul>
            <li>Validierung stellt Korrektheit sicher</li>
            <li>Validierung stellt keine Sicherheit sicher</li>
            <li>Isolierung durch formlose Betrachtung der Eingaben</li>
            <li>Isolierung durch z.B. Prepared-Statements</li>
            <li>Mindestens Validierung des Tokens (zumeist über Signature/Secret)</li>
            <li>Eventuelle Überprüfung der Zugriffsrechte</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <textarea data-template>
          ### Architekturen
        </textarea>
      </section>
      <!-- Architekturen -->
      <section>
        <textarea data-template>
          #### Architekturen

          - Monolith
          - Modulith
          - Services
          - Microservice
        </textarea>
      </section>
      <section>
        <h4>Architekturen - Monolith</h4>
        <img src="assets/monolith.svg" height="400">
      </section>
      <section>
        <textarea data-template>
          #### Architekturen - Monolith

          - Alle Aspekte der Anwendung in einem Projekt
          - Keine Trennung zwischen Fachlichkeiten
          - Keine externen Abhängigkeiten zur Laufzeit
        </textarea>
      </section>
      <section>
        <h4>Architekturen - Modulith</h4>
        <img src="assets/modulith.svg" height="400">
      </section>
      <section>
        <textarea data-template>
          #### Architekturen - Modulith

          - Unterteilung der Anwendung in Fachlichkeiten
          - Auslagerung der Fachlichkeiten in Module
          - Module definieren öffentliche Schnittstellen
          - Auslagerung in Form von Package, Modul, Projekt
          - Keine Auslagerung zur Laufzeit
          - Zusammengeführt durch Kern
        </textarea>
      </section>
      <section>
        <h4>Architekturen - Services</h4>
        <img src="assets/services.svg" height="400">
      </section>
      <section>
        <textarea data-template>
          #### Architekturen - Services

          - Modulith als Kern
          - Auslagerung einzelner Module in Services
          - Services haben eigene Datenhaltung
        </textarea>
        <aside class="notes">
          <ul>
            <li>Daten müssen nicht repliziert werden, da Kern das Mapping übernimmt</li>
          </ul>
        </aside>
      </section>
      <section>
        <h4>Architekturen - Microservices</h4>
        <img src="assets/microservices.svg" height="400">
      </section>
      <section>
        <textarea data-template>
          #### Architekturen - Microservices

          - Auslagerung jedes Modules in Services
          - Expliziter Kern durch implizite Abhängigkeiten zwischen Services ersetzt
          - Services replizieren Daten in eigener Datenhaltung
        </textarea>
        <aside class="notes">
          <ul>
            <li>Daten müssen repliziert werden, da es keinen Kern fürs Mapping gibt</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <textarea data-template>
          ### Vergleich
        </textarea>
      </section>
      <!-- Kriterien -->
      <section>
        <textarea data-template>
          #### Vergleich - Kriterien

          - Initialaufwand
          - Wartungsaufwand
          - Betriebsaufwand
          - Personalaufwand
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Kriterien

          - Abhängigkeit
          - Ausführbarkeit
          - Testbarkeit
          - Skalierbarkeit
          - Zuverlässigkeit
          - Ausfallsicherheit
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Initialaufwand

          - Aufsetzten der Architektur
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Initialaufwand

          Monolith   Modulith   Services   Microservices
          Gering     Mittel     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith braucht kein Konzept</li>
            <li>Modulith braucht einfaches Konzept</li>
            <li>Services braucht erweitertes Konzept</li>
            <li>Microservices braucht allgemeines Konzept</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Wartungsaufwand

          - Einführung neuer Features
          - Entfernung alter Features
          - Behebung von Fehler
          - Aktualisierung der Abhängigkeiten
          - Refactoring
        </textarea>
        <aside class="notes">
          <ul>
            <li>Abhängigkeiten sind Sprache, Frameworks, Libraries, Services, Datenbanken, Schnittstellen</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Wartungsaufwand

          Monolith   Modulith   Services   Microservices
          Hoch       Mittel     Mittel     Gering
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: stark erhöhter Aufwand</li>
            <li>Modulith: Module leicht erweiterbar; Kern erhöhter Aufwand</li>
            <li>Services: Aufwand abhängig von Kern oder Service</li>
            <li>Microservices: können vollständig neugeschrieben werden</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Betriebsaufwand

          - Betreiben der Services
          - Instandhaltung der Umgebung
          - Behebung von Störungen
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Betriebsaufwand

          Monolith   Modulith   Services   Microservices
          Gering     Gering     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: wenige, große Instanzen; wenige Server, physische Umgebung</li>
            <li>Modulith: s.h. Monolith</li>
            <li>Services: wenige, große Instanzen + kleine, evt. häufige Services; einige Server, evt. partiell virtualisierte Umgebung</li>
            <li>Microservices: viele, kleine Instanzen; viele Server, virtualisierte Umgebung</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Personalaufwand

          - Teamgröße sowie Teamanzahl
          - Erhöhte Komplexität erfordert mehr Personal
          - Mehr Personal erfordert erhöhte Flexibilität
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Personalaufwand

          Monolith   Modulith   Services   Microservices
          Gering     Mittel     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: sehr kleines Entwicklungsteam benötigt; Operations durch Entwickler</li>
            <li>Modulith: sehr kleines bis kleines Entwicklungsteam benötigt; evt. extra Personal für Operations</li>
            <li>Services: Entwicklungsteam abhängig von Größe des Projektes; extra Personal für Operations</li>
            <li>Microservices: ein, großes bis mehrere, kleine Entwicklungsteams; klein bis mittleres Operationsteam</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Abhängigkeit

          - Trennung der Fachlichkeiten
          - Freiheit der Technologien
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Abhängigkeit

          Monolith   Modulith   Services   Microservices
          Hoch       Hoch       Mittel     Gering
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: sehr starke Kopplung, keine Kohäsion</li>
            <li>Modulith: mäßige Kopplung, gewisse Kohäsion</li>
            <li>Services: losere Kopplung, partiell hohe Kohäsion; mehrere Sprachen/Frameworks möglich</li>
            <li>Microservices: lose Kopplung, hohe Kohäsion; mehrere Sprachen/Frameworks/Images möglich</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Ausführbarkeit

          - Ausprobieren neuer Features
          - Nachstellen von Fehler
          - Aufsetzen der Umgebung
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Ausführbarkeit

          Monolith   Modulith   Services   Microservices
          Hoch       Hoch       Mittel     Gering
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: nur eine Instanz benötigt</li>
            <li>Modulith: s.h. Monolith</li>
            <li>Services: mehre Instanzen benötigt</li>
            <li>Microservices: mehrere Instanzen und Umgebung benötigt</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Testbarkeit

          - Validierung der Korrektheit
          - Absichern von Entwicklungen
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Testbarkeit

          Monolith   Modulith   Services   Microservices
          Gering     Mittel     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: nur in Gesamtheit testbar</li>
            <li>Modulith: einzelne Module testbar, Kern nur in Gesamtheit</li>
            <li>Services: einzelne Module/Services testbar</li>
            <li>Microservices: einzelne Services modular testbar</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Skalierbarkeit

          - Reaktionsfähigkeit bei Fluktuationen
          - Effiziente Nutzung der Resourcen
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Skalierbarkeit

          Monolith   Modulith   Services   Microservices
          Keine      Gering     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: nicht skalierbar</li>
            <li>Modulith: einzelne Module über Threading skalierbar</li>
            <li>Services: einzelne Services können skaliert werden</li>
            <li>Microservices: alle Services können skaliert werden</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Zuverlässigkeit

          - Störungsanfälligkeit
          - Kommunikationsabbrüche
          - Fehlerhafte Zustände
          - Netzwerke, Hardware, Software
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Zuverlässigkeit

          Monolith   Modulith   Services   Microservices
          Hoch       Hoch       Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: kaum Netzwerkverbindung; keine Interaktion zwischen Servergruppen; wenig Teile</li>
            <li>Modulith: s.h Monolith</li>
            <li>Services: Kommunikation zwischen Kern und Service anfällig; mehrere Teile</li>
            <li>Microservices: Netzwerkvirtualisierung und Servergruppen anfällig; viele Teile</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Ausfallsicherheit

          - Ausfallsicherheit
          - Redundanz
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Ausfallsicherheit

          Monolith   Modulith   Services   Microservices
          Gering      Gering     Mittel     Hoch
        </textarea>
        <aside class="notes">
          <ul>
            <li>Monolith: Single-Point-of-Failure</li>
            <li>Modulith: s.h Monolith</li>
            <li>Services: Kern Single-Point-of-Failure, Services redundant</li>
            <li>Microservices: alle Services redundant</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Anforderungen

          Monolith              Modulith                Services                Microservices
          Unbekannt - Einfach   Einfach - Umfangreich   Umfangreich - Komplex   Komplex
        </textarea>
        <aside class="notes">
          <ul>
            <li>Anforderungen und Teamgröße limitieren Architekturmöglichkeiten</li>
            <li>Architektur nach Konvergierung von Anforderungen und Personalaufwand wählen</li>
            <li>Teamgröße muss sich mit Anforderungen decken</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Teamgröße

          Monolith   Modulith       Services        Microservices
          Klein      Klein - Groß   Mittel - Groß   Groß - Mehrere
        </textarea>
        <aside class="notes">
          <ul>
            <li>Anforderungen und Teamgröße limitieren Architekturmöglichkeiten</li>
            <li>Architektur nach Konvergierung von Anforderungen und Personalaufwand wählen</li>
            <li>Teamgröße muss sich mit Anforderungen decken</li>
          </ul>
        </aside>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Zusammenfassung

          {placeholder:comparison_table}
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Fazit

          - Anforderungen und Teamgröße limitieren jeweils Architekturmöglichkeiten
          - Architektur aus Deckung der Architekturmöglichkeiten wählen
          - Teamgröße muss sich mit Anforderungen decken
        </textarea>
      </section>
      <section>
        <textarea data-template>
          #### Vergleich - Fazit

          - Monolith für unbekannte Projekte
          - Modulith für mehr Wartbarkeit
          - Services für Skalierbarkeit
          - Microservices für Zuverlässigkeit
        </textarea>
      </section>
    </section>
    <section>
      <section data-markdown>
        <textarea data-template>
          ### Spring
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring

          - Application Framework
          - Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring-Boot

          - Basiert auf Spring
          - Erweitert um Java EE
          - Convention-over-Configuration
          - Annotation-Base Configuration
            - Spring ursprünglich eigentlich XML
        </textarea>
        <aside class="notes">
          <ul>
            <li>Spring besteht aus Modulen die miteinander kombiniert werden können</li>
            <li>Spring Boot erweitert Spring um Java EE (Servlets)</li>
            <li>Standardkonfiguration wird bevorzugt, am besten keine komplizierte Konfiguration</li>
            <li>Abweichend davon kostet es Konfigurationsaufwand</li>
          </ul>
        </aside>
      </section>
      <!-- Spring - Bootstrap -->
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap

          - Aufbau des Objektgraphen
          - Zwei primäre Quellen für Objekte
            - Components
            - Configurations
          - Objektgraph ist normalerweise statisch
          - Objektgraph erlaubt dynamische Erweiterung
        </textarea>
        <aside class="notes">
          <ul>
            <li>Objektgraphen ist der Graph den der Dependency Injection Container aufbaut</li>
            <li>Quellen -> Einstiegspunkte für den Graphen</li>
            <li>zu jeder Zeit können Objekte zur Laufzeit hinzugefügt werden</li>
          </ul>
        </aside>
      </section>
      <section data-markdown>
        <textarea data-template>
          ### Bootstrap
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Verwendung

          - `@SpringBootApplication` zur Deklaration des Einstiegspunkt
          - `@ComponentScan` für komplexere Umstände
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Beispiel

          ```java
          @SpringBootApplication
          public class MySpringApplication {
              public static void main(String[] args) {
                  SpringApplication.run(MySpringApplication.class, args);
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Bootstrap - Details

          `@SpringBootApplication`
          - `scanBasePackages` Base-Package für alle Configurations und Components
            - Default ist das aktuelle Package
        </textarea>
      </section>
      <!-- Spring - Components -->
      <section data-markdown>
        <textarea data-template>
          #### Components

          - Direkte Deklaration von Objekten
          - Erzeugung durch den Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Verwendung

          - `@Component` zur Deklaration
          - `@Order` zur Definition der Präzedenz
        </textarea>
        <aside class="notes">
          <ul>
            <li>@Order wird nur gebraucht wenn man bestehende Components einer Library überschreiben möchte</li>
          </ul>
        </aside>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Beispiel

          ```java
          @Component
          public class MyComponent {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Components - Aliase

          - `@Controller` für Endpoints
          - `@RestController` für ReST-Endpoints
          - `@Services` für Services
          - `@Repository` für Datenbankschnittstellen
        </textarea>
      </section>
      <!-- Spring - Configurations -->
      <section data-markdown>
        <textarea data-template>
          #### Configurations

          - Indirekte Deklaration von Objekten
          - Sowie Ändern und Erweitern bestehender Objekte
          - Aufruf durch den Dependency-Injection-Container
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Configurations - Verwendung

          - `@Configuration` zur Deklaration einer Konfiguration
          - `@Bean` zur Deklaration eines Objektes
          - `@Order` zur Definition der Präzedenz
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Configurations - Beispiel

          ```java
          @Configuration
          public class MyConfiguration {
              @Bean
              public MyComponent createComponent(){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <!-- Spring - Referenzierung -->
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung

          - Benötigt Aufruf durch Dependency-Injection-Container
          - Auflösung der Referenzen über Typ
          - Mehrfach vorhandene Objekt über Namen ggf. Classifier
          - Boostrap scheitert wenn Referenz nicht auslösbar
            - keine entsprechendes Objekt
            - mehrere entsprechende Objekte
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Verwendung

          - `@Autowired` zur Markierung eines Parameters
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Beispiel

          ```java
          @Component
          public class MyComponentWithDependency {
              public MyComponentWithDependency(@Autowired MyRequiredComponent component){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Beispiel

          ```java
          @Configuration
          public class MyConfiguration {
              @Bean
              public MyComponentWithDependency createDependantComponent(@Autowired MyRequiredComponent component){
                  ...
              }
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Referenzierung - Details

          `@Autowired`
          - `required` für optionale Objekte
        </textarea>
        <aside class="notes">
          <ul>
            <li>required ist ein Attribut von Autowired</li>
            <li>wird z.B. für Libraries verwendet</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section data-markdown>
        <textarea data-template>
          ### Spring Schichten
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Spring Schichten

          - Frontend
          - Middleware
          - Backend
        </textarea>
      </section>
      <!-- Spring - Controllers -->
      <section data-markdown>
        <textarea data-template>
          #### Controller

          - Schnittstelle zur Außenwelt
          - Abstraktes Konstrukt
          - Verschiedene Arten von Schnittstellen möglich (ReST, GraphQL etc.)
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Controller - Einordnung

          - Frontend
          - Referenziert Services
          - Wird von niemanden referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Controller - Verwendung

          - `@Controller` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller

          - Konkrete Ausprägung eines Controllers
          - ReST basiert
          - Definiert die Endpoints der Anwendung
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Verwendung

          - `@RestController` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Verwendung

          - `@RequestMapping` zur Definition des Endpoints
          - `@PathVariable` für Pfad-Variablen
          - `@QueryParam` für Query-Parameter
          - `@RequestBody` für Bodies
          - `@ResponseStatus` für besondere Http-Status
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RestController
          @RequestMapping(path = "/notes", produces = MediaType.APPLICATION_JSON)
          public class MyNoteController {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notizen holen
          `GET /notes`

          Notizen suchen
          `GET /notes?q={search}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(method = RequestMethod.GET)
          public List<Note> getNotes(
              @RequestParam(name = "q", required = false) String search
          ) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz anlegen
          `POST /notes`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(method = RequestMethod.POST)
          public Note createNote(@RequestBody NoteProposal proposal) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz ändern
          `PUT /notes/{note}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(path = "/{note}", method = RequestMethod.PUT)
          public Note updateNote(
              @PathVariable("note) Long noteId,
              @RequestBody NoteProposal proposal
          ) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Notiz ändern
          `DELETE /notes/{note}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(path = "/{note}", method = RequestMethod.DELETE)
          public Note deleteNote(
              @PathVariable("note) Long noteId,
              @RequestBody NoteProposal proposal
          ) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          Anhang holen
          `GET /notes/{note}/attachment/{attachment}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Beispiel

          ```java
          @RequestMapping(
              path = "/{note}/attachment/{attachment}",
              method = RequestMethod.GET,
              produces = MediaType.APPLICATION_OCTET_STREAM_VALUE
          )
          public byte[] getAttachment(
              @PathVariable("note") Long noteId,
              @PathVariable("attachment) String attachmentId
          ) {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Rest-Controller - Details

          `@RequestMapping`
          - `path` Pfad ink. Pfad-Variablen
          - `method` Erwartete Methode
          - `consumes` Erwarteter Content-Type
          - `produces` Erzeugter Content-Type
        </textarea>
      </section>
      <!-- Spring - Service -->
      <section data-markdown>
        <textarea data-template>
          #### Service

          - Implementiert Businesslogik
          - Oftmals durch ein Interface abstrahiert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Einordnung

          - Middleware
          - Referenziert Repositories und andere Services
          - Wird von Controller und Services referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Verwendung

          - `@Service` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Beispiel

          ```java
          @Service
          public interface MyNoteService {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Service - Beispiel

          ```java
          @Service
          public class MyNoteServiceImpl implements MyNoteService {
              ...
          }
          ```
        </textarea>
      </section>
      <!-- Spring - Repository -->
      <section data-markdown>
        <textarea data-template>
          #### Repository

          - Implementiert Datenbankschnittstelle für eine Entity
          - Abstraktes Konstrukt
          - Verschiedene Arten von Datenbankschnittstelle möglich (JPA, ElasticSearch etc.)
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Repository - Einordnung

          - Backend
          - Referenziert andere Repositories
          - Wird von Services referenziert
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Repository - Verwendung

          - `@Repository` zur Deklaration
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository

          - Basiert auf Java-Persistence-API
          - Implementation per Proxy
          - Erweiterung durch Annotationen
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Verwendung

          - `@Repository` zur Deklaration
          - `@Query` zur Definition komplexer Queries
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Repository
          public interface MyNoteRepository extends JpaRepository<Note, Long> {
              ...
          }
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          List<Note> findAll();
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          Note findById(Long id);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          Note findByNameAndDescription(String name, String description);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Query("SELECT n FROM Notes n WHERE n.tag IN (:tags) AND n.creationDate >= :timestamp")
          Note findWithTagsAfter(String[] tags, OffsetDateTime timestamp);
          ```
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Better Practice

          - Vielzahl an vordefinierten Operationen
          - Wrapper-Klasse für explizite Schnittstellen
          - Mehr Aufwand - Mehr Konsistenz
            - Projekt-spezifisches Wording
            - Vermeidung von `Optional`
            - Keine ungewollten Operationen
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### JPA-Repository - Beispiel

          ```java
          @Repository
          public class MyNoteRepository {
              private @Autowired MySpringNoteRepository delegate;

              public @Nullable Note find(@NotNull Long id) {
                  return delegate.findById(id).orElse(null)
              }
          }
          ```
        </textarea>
      </section>
    </section>
    <section>
      <section data-markdown>
        <textarea data-template>
          ### TODO Anwendung
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### TODO Anwendung - Anforderungen

          - TODOs abfragen
          - TODO anlegen
          - TODO als Done markieren
          - TODO löschen
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### TODO Anwendung - Anforderungen

          TODOs abfragen
          `GET /todo`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### TODO Anwendung - Anforderungen

          TODO anlegen
          `POST /todo`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### TODO Anwendung - Anforderungen

          TODO als Done markieren
          `PUT /todo/{id}`
        </textarea>
      </section>
      <section data-markdown>
        <textarea data-template>
          #### TODO Anwendung - Anforderungen

          TODO löschen
          `DELETE /todo/{id}`
        </textarea>
      </section>
    </section>
  </div>
</div>

<script src="/dist/reveal.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script>
  Reveal.initialize({
    hash: true,
    slideNumber: true,
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
    dependencies: [
      {src: '//cdn.jsdelivr.net/npm/reveal-plantuml'},
    ]
  });
</script>
</body>
</html>
