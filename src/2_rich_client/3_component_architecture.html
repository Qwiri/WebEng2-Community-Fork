<section>
  <h3>Component Architecture</h3>
  <img src="assets/error-lego.jpg" style="height: 400px;">
  <aside class="notes">
    <ul>
      <li>Component Architecture könnte man sich wie Lego vorstellen</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Component Architecture</h4>
  <ul>
    <li>divide et impera
      <ul>
        <li>teilen der Webseite in einzelnen Components</li>
        <li>Verteilung und Strukturierung der Komplexität</li>
      </ul>
    </li>
    <li>Components
      <ul>
        <li>enthalten zusammengehörige Funktionalität
          <ul>
            <li>quasi wie Klassen in OOP</li>
          </ul>
        </li>
        <li>haben feste Schnittstellen
          <ul>
            <li>möglichst lose Kopplung und hohe Kohäsion</li>
            <li>analog wie Legosteine</li>
          </ul>
        </li>
        <li>abstrahieren Struktur und Styling</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>divide et impera: steht natürlich nur auf der Folien, weil lateinische Wörter klug aussehen</li>
      <li>Die Idee ist aber grundlegend seine Webseite in einzelne Components aufzuteilen.</li>
      <li>Damit teilt man die Komplexität seiner Seite in kleinere Teile (Components).</li>
      <li>Quasi wie man es aus dem klassischen Softwareengineering kennt. Dort wird auch funktionalität die zusammengehört in Klassen zusammengefasst.</li>
      <li>Über Schnittstellen (vergleich zu Lego die Noppen), können Components dann wieder zusammengesteckt werden.</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Component Architecture</h4>
  <img src="assets/lego-component-example.jpg" style="height: 400px;">
</section>
<section>
  <h4>Component Architecture</h4>
  <ul>
    <li>SRP: Single Responsible Principle</li>
    <li><em>"A class should have only one reason to change."</em></li>
    <li><em>"A module should be responsible to one, and only one, actor."</em></li>
    <li>dies ist auch auf Components anwendbar</li>
    <li>Components sollten
      <ul>
        <li>nur einen Grund haben sich zu ändern</li>
        <li>nur einem Akteur gegenüber verantwortlich sein</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Zitate von Robert C. Marting SOLID und Clean Architecture</li>
      <li>Man könnte sich denken, dass dies nur bei kleineren Components möglich ist</li>
      <li>Doch auch eine Page hat eine Verantwortlichkeit und damit nur einen Grund sich zu ändern</li>
      <li>Bzw. sie ist gegenüber einem Akteur verantwortlich</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Component Architecture</h4>
  <ul>
    <li>Was könnte man sich alles als Component vorstellen?
      <ul>
        <li>Buttons, Text Fields, Labels, etc.</li>
        <li>Search Bar, Form Groups, Cards, etc.</li>
        <li>Header, Footer, Overlays, etc.</li>
        <li>Pages</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Unter einer Card kann man sich gebündelten Content vorstellen. Möglicherweise mit Bild und Edit Button oder so?</li>
      <li>Eine Component kann also ein sehr kleiner Teil der Anwendung sein, wie z.B. ein einzelner Button</li>
      <li>Eine Component kann aber auch ein Abschnitt sein oder sogar eine ganze Seite, die sich mit einem bestimmten Thema beschäftigt.</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Components</h4>
  <pre>
                    <code class="language-html" data-line-numbers>&lt;button value=&quot;Submit&quot; onclick=&quot;alert(&#39;Button clicked!&#39;)&quot;/&gt</code>
                </pre>
  <ul>
    <li>Components haben wie Classes feste Schnittstellen</li>
    <li>damit können sie modular eingesetzt werden</li>
    <li>normalerweise gibt es Input und Output Parameter</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>normalerweise gibt man etwas in eine Component hinein und bekommt etwas aus der Component zurück</li>
      <li>wir setzen mit der Component Architecture auf klassischen HTML Elementen auf und bauen daraus größere Components</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Components</h4>
  <p>Beispiel (Angular):</p>
  <pre>
                  <code class="typescript" data-line-numbers>export class TextInputComponent {

    @Input()
    placeholder: string;
    @Output()
    text: EventEmitter&lt;string&gt;;

    someLogic() {
        // some logic
    }
}                   </code>
                </pre>
  <aside class="notes">
    <ul>
      <li>Jetzt fragen sie sich vielleicht, warum sollte ich eine TextInputComponent selbst bauen? Die gibts doch schon in HTML?</li>
      <li>Components abstrahieren nicht nur Struktur (HTML) sondern liefern gleich auch das Styling mit.</li>
      <li>der Aufrufer einer Component soll lediglich Input und Output mitgeben und sich um Struktur und Styling keine Gedanken machen müssen.</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Aufbau einer Component Architecture</h4>
  <p>meist nach dem MVC Pattern</p>
  <img src="assets/MVC.png" style="height: 400px">
  <aside class="notes">
    <ul>
      <li>um dies besser zu verstehen schauen wir uns dies anhand eines Angular Beispiels an</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Aufbau einer Component: Beispiel Angular</h4>
  <aside class="notes">
    <ul>
      <li>grundsätzlich besteht eine Component aus getrenntem Typescript, HTML und CSS</li>
      <li>die Trennung macht eine Component in sich übersichtlich</li>
      <li>es empfiehlt sich möglichst wenig Logik im HTML zu hinterlassen, dafür ist das Typescript File</li>
      <li>der View ist damit also klar. Das ist das HTML.</li>
      <li>als Model werden normalerweise Services in Angular betrachtet</li>
      <li>Services sind reiner Typescriptcode. Es handelt sich hierbei wieder um Komponenten in denen nur Logik oder Backendaufrufe stattfinden.</li>
      <li>Sie stellen also die Daten bereit, die in der View angezeigt werden können</li>
      <li>Als Controller kann man sich damit den Typescript Part der Component vorstellen.</li>
      <li>Oft wird das Angular Component System nicht mit MVC, sondern MVVM bezeichnet. Model View ViewModel.</li>
      <li>Das heißt das Typescript File übersetzt das Model noch mal in ein ViewModel, dass dann direkt angezeigt werden kann</li>
      <li>Ich gehe später noch mal genauer auf die einzelne Syntax etc. von Angular ein, damit ihr auch ein Praxisbeispiel dazu bauen könnt.</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Component Architecture</h4>
  <ul>
    <li>Vorteile:
      <ul>
        <li>Konsistenz im Styling</li>
        <li>Wiederverwendbarkeit</li>
        <li>schnellere Entwicklung</li>
        <li>einfachere Instandhaltung </li>
      </ul>
    </li>
    <li>Nachteile:
      <ul>
        <li>tiefe Verschachtelungen möglich</li>
        <li>Logik in den Components</li>
        <li>im Prinzip immer noch ein Monolith (Modulith)</li>
        <li>mehrere Teams an einem Artefakt ist nicht optimal</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <!--TODO evtl. hier noch weitere Folien hinzufügen um die Vorteile/Nachteile zu vertiefen-->
    <ul>
      <!--Vorteile-->
      <li>Konsistenz
        <ul>
          <li>Komponenten wie Buttons gehören zu Atomen und sollten wiederverwendet werden.</li>
          <li>Dies spart Zeit, außerdem sehen die Button überall gleich aus. Sorgt für Konsistenz im Styling</li>
        </ul>
      </li>
      <li>Schnellere Entwicklung
        <ul>
          <li>Ich muss den Button nicht noch mal für eine andere Seite Stylen oder mit den Code dazu kopieren.</li>
          <li>Ich kann auf bereits basierende Strukturen aufbauen.</li>
        </ul>
      </li>
      <!--Nachteile-->
      <li>tiefe Verschachtelungen
        <ul>
          <li>Große Seiten und Anwendungen kämpfen häufig mit einer sehr hohen Verschachtelungstiefe</li>
          <li>Durch Komponenten die kein Styling hinzufügen, sondern nur Logik bereitstellen und teilen, wird die Wrapper Hölle noch schlimmer.</li>
          <li>Dies ist nicht sehr übersichtlich.</li>
        </ul>
      </li>
      <li>Logik in Components
        <ul>
          <li>View Components sollten relativ frei von Logik sein.</li>
          <li>Logik sollte in Services oder ähnliches ausgelagert werden.</li>
        </ul>
      </li>
    </ul>
  </aside>
</section>
<section>
  <h4>Component Architecture Frameworks</h4>
  <ul>
    <li>Angular</li>
    <li>React</li>
    <li>Vue</li>
    <li>und viele mehr...</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>die meisten JavaScript SPA Frameworks setzen auf eine Component Architecture.</li>
      <li>die Frameworks unterscheiden sich meistens nur in Details, Syntax, Performance.</li>
      <li>hat man die Basis, also Component Architectures verstanden, so kann man sich leicht an neue Frameworks gewöhnen</li>
      <li>kann man eins, kann man alle...</li>
      <li>es gibt allerdings doch einige unterschiede, die wir uns jetzt anschauen wollen.</li>
      <li>Dazu könnt ihr euch das mal ansehen: https://academind.com/tutorials/angular-vs-react-vs-vue-my-thoughts/</li>6
      <li>wir schauen uns später konkret Angular an.</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Angular</h4>
  <ul>
    <li>mehr eine Plattform als ein Framework</li>
    <li>kann einiges "out of the box"
      <ul>
        <li>DOM Manipulation</li>
        <li>State Management</li>
        <li>Routing</li>
        <li>Form Validation</li>
        <li>HTTP Client</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>bringt fast alles mit was man braucht</li>
      <li>Vorteil: Versionen sind im Angular Ökosystem kompatibel</li>
      <li>kann jedoch trotzdem um Libraries erweitert werden</li>
    </ul>
  </aside>
</section>
<section>
  <h4>React</h4>
  <ul>
    <li>sehr leichtgewichtig</li>
    <li>reduziert auf
      <ul>
        <li>DOM Manipulation</li>
        <li>State Management</li>
      </ul>
    </li>
    <li>nur die Basis für die Component Architecture</li>
    <li>erweiterbar über Libraries</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>sehr leichtgewichtig</li>
      <li>Libraries durch eine große Community</li>
      <li>Versionsproblematik mit externen Libraries</li>
    </ul>
  </aside>
</section>
<section>
  <h4>Vue</h4>
  <ul>
    <li>liegt zwischen Angular und React</li>
    <li>bietet
      <ul>
        <li>DOM Manipulation</li>
        <li>Sate Management</li>
        <li>Routing</li>
      </ul>
    </li>
  </ul>
</section>
