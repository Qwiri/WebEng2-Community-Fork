<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>4_rich_client_server</title>

  <link rel="stylesheet" href="/dist/reset.css">
  <link rel="stylesheet" href="/dist/reveal.css">
  <link rel="stylesheet" href="/dist/theme/white.css">

  <link rel="stylesheet" href="/node_modules/highlight.js/styles/stackoverflow-dark.css">
  <link rel="stylesheet" href="/src/custom_styles/global_styles.css">
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section>
      <h3>Rich Client: Server</h3>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Wiederholung
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Verantwortlichkeiten - JSF

          - View-Management
          - State-Management
          - Rendering
          - Events
          - Routing
          - Validation
          - Data-Management
          - Persistence
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Verantwortlichkeiten - Rich Client

          - View-Management
          - State-Management
          - Rendering
          - Events
          - Routing
          - Ensurance
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Verantwortlichkeiten - Webservice

          - Validation
          - Data-Management
          - Persistence
        </div>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Webservice
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Webservice

          Drei grundlegende Eigenschaften:
          - Stateless
          - Scalable
          - Untrusting
        </div>
        <aside class="notes">
          <ul>
            <li>Keine Übertragung von Zustandsänderungen</li>
            <li>Keine Übertragung von unzusammenhängenden Informationen</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Webservice - Stateless

          - Kein Zustand
          - Keine Session
          - Anfrage ausschließlich mit fachlichen Informationen
        </div>
        <aside class="notes">
          <ul>
            <li>Keine Übertragung von Zustandsänderungen</li>
            <li>Keine Übertragung von unzusammenhängenden Informationen</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Webservice - Stateless

          - Keine nicht-persistenten Informationen
          - Transparentes Caching ausgenommen
          - Persistierung in Datenbank oder Dateisystem
          - Transparente Datenbank oder Dateisystem
        </div>
        <aside class="notes">
          <ul>
            <li>Keine anfrageübergreifende Informationen</li>
            <li>Transparente Caches agieren auf persistenten oder berechenbaren Daten</li>
            <li>Transparente Caches agieren niemals auf flüchtigen Daten</li>
            <li>Transparente Caches für persistente Daten müssen kurzlebig oder Änderungen bewusst sein</li>
            <li>Transparente Datenbanken/Dateisysteme (ver)teilen über mehrere Instanzen</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Webservice - Scalable

          - Abhängig von ausschließlich externen Informationen
            - Eingaben des Clients
            - Daten der Persistence
          - Instanzen sind identitätslos
          - Dynamisches hoch-/runterfahren von Instanzen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Webservice - Untrusting

          - Validierung aller Eingaben
          - Isolierung aller Eingaben
          - Durchgehende Prüfung der Authorisierung
        </div>
        <aside class="notes">
          <ul>
            <li>Validierung stellt Korrektheit sicher</li>
            <li>Validierung stellt keine Sicherheit sicher</li>
            <li>Isolierung durch formlose Betrachtung der Eingaben</li>
            <li>Isolierung durch z.B. Prepared-Statements</li>
            <li>Mindestens Validierung des Tokens (zumeist über Signature/Secret)</li>
            <li>Eventuelle Überprüfung der Zugriffsrechte</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Architekturen
        </div>
      </section>
      <section>
        <h4>Architekturen</h4>
        <img src="assets/architecture-blackbox.svg" height="400">
      </section>
      <section>
        <h4>Architekturen</h4>
        <img src="assets/architecture-whitebox.svg" height="400">
      </section>
      <section>
        <div data-markdown>
          #### Architekturen

          - Aufteilung von Verantwortlichkeiten
          - Abgrenzung einzelner Komponenten
          - Interaktion zwischen Komponenten
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Architekturen

          - Architektur bedingt API
          - API bedingt nicht die Architektur
        </div>
      </section>
      <!-- Architekturen -->
      <section>
        <div data-markdown>
          #### Architekturen

          - Monolith
          - Modulith
          - Services
          - Microservice
        </div>
      </section>
      <section>
        <h4>Architekturen - Monolith</h4>
        <img src="assets/monolith.svg" height="400">
      </section>
      <section>
        <div data-markdown>
          #### Architekturen - Monolith

          - Alle Aspekte der Anwendung in einem Projekt
          - Keine Trennung zwischen Fachlichkeiten
          - Keine externen Abhängigkeiten zur Laufzeit
        </div>
      </section>
      <section>
        <h4>Architekturen - Modulith</h4>
        <img src="assets/modulith.svg" height="400">
      </section>
      <section>
        <div data-markdown>
          #### Architekturen - Modulith

          - Unterteilung der Anwendung in Fachlichkeiten
          - Auslagerung der Fachlichkeiten in Module
          - Module definieren öffentliche Schnittstellen
          - Auslagerung in Form von Package, Modul, Projekt
          - Keine Auslagerung zur Laufzeit
          - Zusammengeführt durch Kern
        </div>
      </section>
      <section>
        <h4>Architekturen - Services</h4>
        <img src="assets/services.svg" height="400">
      </section>
      <section>
        <div data-markdown>
          #### Architekturen - Services

          - Modulith als Kern
          - Auslagerung einzelner Module in Services
          - Services haben eigene Datenhaltung
        </div>
        <aside class="notes">
          <ul>
            <li>Daten müssen nicht repliziert werden, da Kern das Mapping übernimmt</li>
          </ul>
        </aside>
      </section>
      <section>
        <h4>Architekturen - Microservices</h4>
        <img src="assets/microservices.svg" height="400">
      </section>
      <section>
        <div data-markdown>
          #### Architekturen - Microservices

          - Auslagerung jedes Modules in Services
          - Expliziter Kern durch implizite Abhängigkeiten zwischen Services ersetzt
          - Services replizieren Daten in eigener Datenhaltung
        </div>
        <aside class="notes">
          <ul>
            <li>Daten müssen repliziert werden, da es keinen Kern fürs Mapping gibt</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Vergleich
        </div>
      </section>
      <!-- Kriterien -->
      <section>
        <div data-markdown>
          #### Vergleich - Kriterien

          - Initialaufwand
          - Wartungsaufwand
          - Betriebsaufwand
          - Personalaufwand
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Kriterien

          - Abhängigkeit
          - Ausführbarkeit
          - Testbarkeit
          - Skalierbarkeit
          - Zuverlässigkeit
          - Ausfallsicherheit
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Initialaufwand

          - Aufsetzten der Architektur
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Initialaufwand

          Monolith | Modulith | Services | Microservices
          ----------|-----------|----------|--------------
          Gering | Mittel | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith braucht kein Konzept</li>
            <li>Modulith braucht einfaches Konzept</li>
            <li>Services braucht erweitertes Konzept</li>
            <li>Microservices braucht allgemeines Konzept</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Wartungsaufwand

          - Einführung neuer Features
          - Entfernung alter Features
          - Behebung von Fehler
          - Aktualisierung der Abhängigkeiten
          - Refactoring
        </div>
        <aside class="notes">
          <ul>
            <li>Abhängigkeiten sind Sprache, Frameworks, Libraries, Services, Datenbanken, Schnittstellen</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Wartungsaufwand

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Hoch | Mittel | Mittel | Gering
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: stark erhöhter Aufwand</li>
            <li>Modulith: Module leicht erweiterbar; Kern erhöhter Aufwand</li>
            <li>Services: Aufwand abhängig von Kern oder Service</li>
            <li>Microservices: können vollständig neugeschrieben werden</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Betriebsaufwand

          - Betreiben der Services
          - Instandhaltung der Umgebung
          - Behebung von Störungen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Betriebsaufwand

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Gering | Gering | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: wenige, große Instanzen; wenige Server, physische Umgebung</li>
            <li>Modulith: s.h. Monolith</li>
            <li>Services: wenige, große Instanzen + kleine, evt. häufige Services; einige Server, evt. partiell virtualisierte Umgebung</li>
            <li>Microservices: viele, kleine Instanzen; viele Server, virtualisierte Umgebung</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Personalaufwand

          - Teamgröße sowie Teamanzahl
          - Erhöhte Komplexität erfordert mehr Personal
          - Mehr Personal erfordert erhöhte Flexibilität
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Personalaufwand

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Gering | Mittel | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: sehr kleines Entwicklungsteam benötigt; Operations durch Entwickler</li>
            <li>Modulith: sehr kleines bis kleines Entwicklungsteam benötigt; evt. extra Personal für Operations</li>
            <li>Services: Entwicklungsteam abhängig von Größe des Projektes; extra Personal für Operations</li>
            <li>Microservices: ein, großes bis mehrere, kleine Entwicklungsteams; klein bis mittleres Operationsteam</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Abhängigkeit

          - Trennung der Fachlichkeiten
          - Freiheit der Technologien
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Abhängigkeit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Hoch | Hoch | Mittel | Gering
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: sehr starke Kopplung, keine Kohäsion</li>
            <li>Modulith: mäßige Kopplung, gewisse Kohäsion</li>
            <li>Services: losere Kopplung, partiell hohe Kohäsion; mehrere Sprachen/Frameworks möglich</li>
            <li>Microservices: lose Kopplung, hohe Kohäsion; mehrere Sprachen/Frameworks/Images möglich</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Ausführbarkeit

          - Ausprobieren neuer Features
          - Nachstellen von Fehler
          - Aufsetzen der Umgebung
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Ausführbarkeit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Hoch | Hoch | Mittel | Gering
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: nur eine Instanz benötigt</li>
            <li>Modulith: s.h. Monolith</li>
            <li>Services: mehrere Instanzen benötigt</li>
            <li>Microservices: mehrere Instanzen und Umgebung benötigt</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Testbarkeit

          - Validierung der Korrektheit
          - Absichern von Entwicklungen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Testbarkeit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Gering | Mittel | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: nur in Gesamtheit testbar</li>
            <li>Modulith: einzelne Module testbar, Kern nur in Gesamtheit</li>
            <li>Services: einzelne Module/Services testbar</li>
            <li>Microservices: einzelne Services modular testbar</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Skalierbarkeit

          - Reaktionsfähigkeit bei Fluktuationen
          - Effiziente Nutzung der Resourcen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Skalierbarkeit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Keine | Gering | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: nicht skalierbar</li>
            <li>Modulith: einzelne Module über Threading skalierbar</li>
            <li>Services: einzelne Services können skaliert werden</li>
            <li>Microservices: alle Services können skaliert werden</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Zuverlässigkeit

          - Störungsanfälligkeit
          - Kommunikationsabbrüche
          - Fehlerhafte Zustände
          - Netzwerke, Hardware, Software
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Zuverlässigkeit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Hoch | Hoch | Mittel | Gering
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: kaum Netzwerkverbindung; keine Interaktion zwischen Servergruppen; wenige Teile</li>
            <li>Modulith: s.h Monolith</li>
            <li>Services: Kommunikation zwischen Kern und Service anfällig; mehrere Teile</li>
            <li>Microservices: Netzwerkvirtualisierung und Servergruppen anfällig; viele Teile</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Ausfallsicherheit

          - Ausfallsicherheit
          - Redundanz
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Ausfallsicherheit

          Monolith | Modulith | Services | Microservices
          ---------|----------|----------|--------------
          Gering | Gering | Mittel | Hoch
        </div>
        <aside class="notes">
          <ul>
            <li>Monolith: Single-Point-of-Failure</li>
            <li>Modulith: s.h Monolith</li>
            <li>Services: Kern Single-Point-of-Failure, Services redundant</li>
            <li>Microservices: alle Services redundant</li>
          </ul>
        </aside>
      </section>
      <section>
        <h4>Vergleich - Zusammenfassung</h4>
        <img src="assets/architecture_comparison.svg" height="600">
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Anforderungen

          | Monolith | Modulith | Services | Microservices |
          |----------|----------|----------|---------------|
          | Unbekannt - Einfach | Einfach - Umfangreich | Umfangreich - Komplex | Komplex |
        </div>
        <aside class="notes">
          <ul>
            <li>Anforderungen und Teamgröße limitieren Architekturmöglichkeiten</li>
            <li>Architektur nach Konvergierung von Anforderungen und Personalaufwand wählen</li>
            <li>Teamgröße muss sich mit Anforderungen decken</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Teamgröße

          | Monolith | Modulith | Services | Microservices |
          |----------|----------|----------|---------------|
          Klein | Klein - Groß | Mittel - Groß | Groß - Mehrere
        </div>
        <aside class="notes">
          <ul>
            <li>Anforderungen und Teamgröße limitieren Architekturmöglichkeiten</li>
            <li>Architektur nach Konvergierung von Anforderungen und Personalaufwand wählen</li>
            <li>Teamgröße muss sich mit Anforderungen decken</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Fazit

          - Anforderungen und Teamgröße limitieren jeweils Architekturmöglichkeiten
          - Architektur aus Deckung der Architekturmöglichkeiten wählen
          - Teamgröße muss sich mit Anforderungen decken
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Vergleich - Fazit

          - Monolith für unbekannte Projekte
          - Modulith für mehr Wartbarkeit
          - Services für Skalierbarkeit
          - Microservices für Zuverlässigkeit
        </div>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Umsetzung
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Technologien - Webengineering I

          - Servlets
            - Rohes HTTP
            - Erfordert eigene Implementierung
          - JSP
            - Implementierung von Servlets
            - Ausschließlich HTML
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Technologien - Webengineering II

          - JSF
            - Implementierung von Servlets
            - Quasi ausschließlich HTML
          - ?
            - Vollständiges HTTP
            - Vielseitige Media-Types
            - Einfache Bedienung
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Technologien - Webengineering II

          - JSF
            - Implementierung von Servlets
            - Quasi ausschließlich HTML
          - Spring, Quarkus, Micronaut...
            - Vollständiges HTTP
            - Vielseitige Media-Types
            - Einfache Bedienung
        </div>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Spring-Boot
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Spring

          - Application Framework
          - Dependency-Injection-Container
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Spring-Boot

          - Basiert auf Spring
          - Erweitert um Java EE
          - Convention-over-Configuration
          - Annotation-Base Configuration
          - Spring ursprünglich eigentlich XML
        </div>
        <aside class="notes">
          <ul>
            <li>Spring besteht aus Modulen die miteinander kombiniert werden können</li>
            <li>Spring Boot erweitert Spring um Java EE (Servlets)</li>
            <li>Standardkonfiguration wird bevorzugt, am besten keine komplizierte Konfiguration</li>
            <li>Abweichend davon kostet es Konfigurationsaufwand</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown data-line-numbers="3">
          #### Spring-Boot - Bootstrap

          ```java
          @SpringBootApplication
          public class MySpringApplication {
              public static void main(String[] args) {
                  SpringApplication.run(MySpringApplication.class, args);
              }
          }
          ```
        </div>
        <aside class="notes">
          <ul>
            <li>Startet eine leere Anwendung</li>
            <li>Trotzdem bietet die Anwendung oftmals bereits Endpunkte wie z.B. /health</li>
          </ul>
        </aside>
      </section>
    </section>
    <!-- Spring - Schichten -->
    <section>
      <section>
        <div data-markdown>
          #### Schichten

          - Frontend
          - Middleware
          - Backend
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Spring Schichten - Frontend

          - Schnittstelle zur Außenwelt
          - Einordnung
            - Wird nicht referenziert
            - Referenziert Middleware
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Spring Schichten - Middleware

          - Implementiert Businesslogik
          - Einordnung
            - Wird von Frontend und Middleware referenziert
            - Referenziert Backend
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Spring Schichten - Backend

          - Persistence Ebene / andere Services
          - Einordnung
            - Wird von Middleware referenziert
            - Referenziert nichts
        </div>
      </section>
    </section>
    <!-- Spring - Frontend -->
    <section>
      <section>
        <div data-markdown>
          ### Frontend
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Frontend

          - Implementierung erfolgt durch Controller
          - API in ReST, GraphQL usw.
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Controller

          ```java
          @RestController
          public class PersonController {
              ...
          }
          ```
        </div>
        <aside class="notes">
          <ul>
            <li>Ein Controller ist der Einstiegspunkt für alle Anfragen</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Methods

          GET /persons
          ```java
          @RestController
          public class PersonController {
              @RequestMapping(
                  method = RequestMethod.GET,
                  path = "/persons"
              )
              public List&lt;Person&gt; getPersons() {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Methods

          POST /persons {"firstName": "John", "lastName": "Doe"}
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @RequestMapping(
                  method = RequestMethod.POST
              )
              public void createPerson(@RequestBody Person person) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Methods

          PUT /persons {"firstName": "John", "lastName": "Doe"}
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @RequestMapping(
                  method = RequestMethod.PUT
              )
              public void updatePerson(@RequestBody Person person) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Methods

          DELETE /persons/John%32Doe
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @RequestMapping(
                  method = RequestMethod.DELETE,
                  path = "/{name}"
              )
              public void deletePerson(@PathVariable String name) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Methods

          Methoden haben Shorthands-Annotations
          - `@RequestMapping(method = RequestMethod.GET)`-> `@GetMapping()`
          - `@RequestMapping(method = RequestMethod.POST)`-> `@PostMapping()`
          - `@RequestMapping(method = RequestMethod.PUT)`-> `@PutMapping()`
          - `@RequestMapping(method = RequestMethod.DELETE)`-> `@DeleteMapping()`
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Paths

          GET /persons
          ```java
          @RestController
          public class PersonController {
              @GetMapping(path = "/persons")
              public List&lt;Person&gt; getPersons() {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Paths

          GET /persons
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @GetMapping
              public List&lt;Person&gt; getPersons() {
                  ...
              }
          }
          ```
        </div>
        <aside class="notes">
          <ul>
            <li>Ganze Pfade können in einem Controller zusammengefasst werden</li>
            <li>Alle Endpunkte des Controllers befinden sich implizit unter der Oberpfad</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Paths

          GET /persons/subpath
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @GetMapping(path = "/subpath")
              public String getSomething() {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Path Variables

          GET /persons/John%32Doe
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @GetMapping(path = "/{name}")
              public Person getPerson(@PathVariable String name) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Parameters

          GET /persons?firstName=John&lastName=Doe
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @GetMapping
              public Person getPerson(
                  @RequestParam String firstName,
                  @RequestParam String lastName
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Bodies

          PUT /persons  {"firstName": "John", "lastName": "Doe"}
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @PutMapping
              public void updatePerson(@RequestBody Person person) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Media-Types

          POST /persons/convert {"firstName": "John", "lastName": "Doe"}
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @PostMapping(
                  path = "/convert",
                  consumes = MediaType.APPLICATION_JSON_VALUE,
                  produces = MediaType.APPLICATION_XML_VALUE
              )
              public Person convertPerson(@RequestBody Person person) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Frontend - Media-Types

          POST /persons/291/document/43006
          ```java
          @RestController
          @RequestMapping(path = "/persons")
          public class PersonController {
              @GetMapping(
                  path = "/{id}/documents/{documentId}",
                  produces = MediaType.APPLICATION_OCTET_STREAM_VALUE
              )
              public byte[] get(
                  @PathVariable Long id,
                  @PathVariable Long documentId
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Frontend - Media-Types

          - Konvertierung zwischen Java und JSON, XML usw.
          - Häufig genutzte Media-Types automatisch unterstützt
          - Darunter z.B. auch Text, HTML oder Binär
          - Serialisierung kann konfiguriert werden
        </div>
      </section>
    </section>
    <!-- Spring - Middleware -->
    <section>
      <section>
        <div data-markdown>
          ### Middleware
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Middleware

          - Implementierung erfolgt durch Services
          - Teilt die Businesslogik in Fachlichkeiten auf
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Middleware - Umsetzung

          - Empfohlen als Interfaces mit Implementierungen
            - Austauschbar
            - Konfigurierbar
          - **aber** keine Pflicht
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Middleware - Service Interface

          ```java
          public interface PersonService {
              Person getPerson(String name);
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Middleware - Service Implementation

          ```java
          @Service
          public class PersonServiceImpl implements PersonService {
              @Override
              public Person getPerson(String name) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Middleware - Default Implementation

          ```java
          @Service
          @ConditionalOnMissingBean(PersonService.class)
          public class DefaultPersonService implements PersonService {
              @Override
              public Person getPerson(String name) {
              ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Middleware - Conditional Implementation

          ```java
          @Service
          @ConditionalOnProperty("service.dumbMode")
          public class DumbModePersonService implements PersonService {
              @Override
              public Person getPerson(String name) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown data-line-numbers>
          #### Middleware - Service

          ```java
          @Service
          public class DocumentService {
          public byte[] getDocument(Person person) {
          ...
          }
          }
          ```
        </div>
      </section>
    </section>
    <!-- Spring - Backend -->
    <section>
      <section>
        <div data-markdown>
          ### Backend
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend

          - Implementierung erfolgt durch Repositories / Services
          - Datenbanken, Dateisystem und anderes Services
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Übersicht

          - Objekt-Relationales-Mapping
          - Entities
          - Abbildungen von Objekten auf Tabellen
          - Transaktionsmanagement
          - Aggregation von zusammengehörigen Änderungen
          - Gewährleistung von Datenintegrität
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Entities

          - `@Entity` zur Deklaration eine Entity
          - `@Id` zur Markierung des ID-Feldes
          - `@GeneratedValue` zur automatischen Generierung
          - usw.
        </div>
        <aside class="notes">
          <ul>
            <li>JPA Annotations sind zahlreich</li>
            <li>Objekt-Relationales-Mapping mithilfe von JPA ist nicht Teil des Rahmens der Vorlesung</li>
            <li>Für ausführliche Informationen zu JPA: https://www.baeldung.com/learn-jpa-hibernate</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          ```java
          @Repository
          public interface PersonRepository
                      extends JpaRepository&lt;Person, Long&gt; {
            ...
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          - Implementiert Datenbankschnittstelle für eine Entity
          - Verschiedene Arten von Datenbankschnittstelle möglich (JPA, ElasticSearch etc.)
          - Deklaration als Interface, Implementierung erfolgt automatisch
          - Queries werden anhand des Names automatisch generiert
          - Standard-Methoden bereits vorgegeben
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          ```java
          List&lt;Person&gt; findAll();
          ```
          `SELECT * FROM person`
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          ```java
          Person findById(Long id);
          ```
          `SELECT * FROM person WHERE id=:personId`
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          ```java
          Person findByFirstNameAndLastName(
              String firstName,
              String lastName
          );
          ```
          `SELECT * FROM person WHERE firstName=:firstName AND lastName=:lastName`
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Backend - JPA Repository

          ```java
          @Query("SELECT n FROM Person p "
                  + "WHERE p.tag IN (:tags) "
                  + "AND p.creationDate >= :timestamp")
          List&lt;Person&gt; findWithTagsAfter(
              String[] tags,
              OffsetDateTime timestamp
          );
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### JPA-Repository - Better Practice

          - Vielzahl an vordefinierten Operationen
          - Wrapper-Klasse für explizite Schnittstellen
          - Mehr Aufwand - Mehr Konsistenz
          - Projekt-spezifisches Wording
          - Verändern der Methodensignatur
          - Keine ungewollten Operationen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### JPA-Repository - Beispiel

          ```java
          @Repository
          public class PersonRepository {
              private final SpringPersonRepository delegate;

              public PersonRepository(
                  @Autowired SpringPersonRepository delegate
              ) {
                  this.delegate = delegate;
              }

              public @Nullable Note find(@NotNull Long id) {
                  return delegate.findById(id).orElse(null)
              }
          }
          ```
        </div>
      </section>
    </section>
    <!-- Spring - Referenzierung -->
    <section>
      <section>
        <div data-markdown>
          ### Referenzierung
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung

          - Spring ist ein Dependency-Injection-Container
          - Bootstrap baut Objektgraphen auf
          - Objektgraph ist normalerweise statisch
          - Objektgraph erlaubt aber dynamische Erweiterung
          - Zwei primäre Quellen für Objekte
            - Components
            - Configurations
        </div>
        <aside class="notes">
          <ul>
            <li>Objektgraphen ist der Graph den der Dependency Injection Container aufbaut</li>
            <li>Quellen -> Einstiegspunkte für den Graphen</li>
            <li>zu jeder Zeit können Objekte zur Laufzeit hinzugefügt werden</li>
          </ul>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Verwendung

          ```java
          @RestController
          public class PersonController {
              public PersonController(
                @Autowired PersonService personService
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Verwendung

          ```java
          @Service
          public class PersonServiceImpl {
              public PersonServiceImpl(
                  @Autowired PersonRepository personRepository
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung

          - Benötigt Aufruf durch Dependency-Injection-Container
          - Auflösung der Referenzen über Typ
          - Mehrfach vorhandene Objekt über Namen ggf. Classifier
          - Boostrap scheitert wenn Referenz nicht auslösbar
            - kein entsprechendes Objekt
            - mehrere entsprechende Objekte
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung

          - Zwei Einstiegspunkte in den Objektgraphen
            - Components
            - Configurations
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Components

          - Klassen direkt oder indirekt annotiert mit `@Component`
          - Durch `@RestController`, `@Service` und `@Repository` indirekt annotiert
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Components

          ```java
          @Component
          public class IndependentComponent {
              ...
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Components

          ```java
          @Component
          public class DependentComponent {
              public DependentComponent(
                  @Autowired RequiredComponent component
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Configurations

          - Klassen annotiert mit `@Configuration` über Methoden annotiert mit `@Bean`
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Configurations

          ```java
          @Configuration
          public class SomeConfiguration {
              @Bean
              public IndependentComponent createComponent() {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Referenzierung - Configurations

          ```java
          @Configuration
          public class SomeConfiguration {
              @Bean
              public DependentComponent createComponent(
                  @Autowired RequiredComponent component
              ) {
                  ...
              }
          }
          ```
        </div>
      </section>
    </section>
    <!-- Spring - Configurations -->
    <section>
      <section>
        <div data-markdown>
          ### Configurations
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Configurations

          - Indirekte Deklaration von Objekten
          - Ändern und Erweitern bestehender Objekte
          - Aufruf durch den Dependency-Injection-Container
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Configurations - Beispiel

          ```java
          @Configuration
          public class MyConfiguration {
              @Bean
              public MyComponent createComponent() {
                  ...
              }
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Configurations - Beispiel

          ```java
          @Configuration
          @EnableWebMvc
          public class WebConfiguration implements WebMvcConfigurer {
              @Override
              public void addCorsMappings(CorsRegistry registry) {
                  registry.addMapping("/**");
              }
          }
          ```
        </div>
      </section>
    </section>
    <!-- Spring - Validation -->
    <section>
      <section>
        <div data-markdown>
          ### Validation
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Validation

          - Überprüfung der Eingaben
          - Client ist nicht vertrauenswürdig
          - Spring unterstützt `javax.validation` Annotations
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Validation - Verwendung

          - `@Valid` zur Markierung von zu validierenden Parametern
          - `@NotNull`
          - `@NotBlank` mindestens EIN nicht Whitespace-Charakter
          - `@Size` Einschränkung der Länge von Strings & Collections
          - `@Min`, `@Max` Einschränkung des numerischen Wertebereichs
          - `@Email` erwartet eine valide Email-Adresse
        </div>
        <aside class="notes">
          <li>Für ausführliche Informationen über javax.validation: https://www.baeldung.com/javax-validation</li>
        </aside>
      </section>
      <section>
        <div data-markdown>
          #### Validation - Beispiel

          ```java
          public class Note {
              ...
              @NotBlank(message = "description must not be blank")
              private String description;
              ...
          }
          ```
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Validation - Beispiel

          ```java
          @PostMapping
          public Note createNote(
              @RequestBody @Valid NoteProposal proposal
          ) {
              ...
          }
          ```
        </div>
      </section>
    </section>
    <section>
      <section>
        <div data-markdown>
          ### Praxis
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - Aufgaben

          - TODOs abfragen
          - TODO anlegen
          - TODO abfragen
          - TODO ändern
          - TODO löschen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - Vorbereitung

          - Repository: `SpringTodoRepository` anlegen, in `TodoRepository` einbinden
          - Service: `TodoServiceImpl` anlegen
          - Controller: `TodoService` in `TodoController` einbinden
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - TODOs abfragen

          `GET /todo`
          - Repository: Methode zum Abrufen alle TODOs anlegen
          - Service: Repository aufrufen
          - Controller: Endpunkt anlegen, Service aufrufe
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - TODO anlegen

          `POST /todo {"title": "Cleanup"}`
          - Repository: Methode zum Speichern anlegen
          - Service: Aus Proposal ein TODO machen, in Repository speichern
          - Controller: Endpunkt anlegen, Service aufrufen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - TODO abfragen

          `GET /todo/{id}`
          - Repository: Methode zum Abrufen eines TODO anlegen
          - Service: Repository aufrufen und Existenz überprüfen
          - Controller: Endpunkt anlegen, Service aufrufen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - TODO ändern

          `PUT /todo/{id} {"done": true}`
          - Repository: -
          - Service: TODO laden, anpassen, in Repository speichern
          - Controller: Endpunkt anlegen, Service aufrufen
        </div>
      </section>
      <section>
        <div data-markdown>
          #### Praxis - TODO löschen

          `DELETE /todo/{id}`
          - Repository: Methode zum Löschen anlegen
          - Service: TODO laden, in Repository löschen
          - Controller: Endpunkt anlegen, Service aufrufen
        </div>
      </section>
      <section>
        <div data-markdown>
          ### Praxis - Validierung

          - `TodoProposal.title`
            - nicht Leer
            - maximal 50 Zeichen
        </div>
      </section>
    </section>
  </div>
</div>

<script src="/dist/reveal.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script>
  Reveal.initialize({
    hash: true,
    slideNumber: true,
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
    dependencies: [
      {src: '//cdn.jsdelivr.net/npm/reveal-plantuml'},
    ]
  });
  Reveal.configure({showNotes: false});
</script>
</body>
</html>
