<section>
    <h3>Arten von Tests</h3>
</section>
<section>
    <h4>Test Pyramide</h4>
    <img src="assets/testpyramide.png" style="height: 400px;">
</section>
<section>
    <h4>Unit Tests</h4>
    <ul>
        <li>automatisierte Tests</li>
        <li>Testen der kleinsten Einheiten</li>
        <li>auf sehr detaillierter Ebene</li>
        <li>kurze Laufzeit</li>
    </ul>
    <aside class="notes">
        <ul>
            <li>Unit Tests müssen automatisiert laufen.</li>
            <li>Wir testen die kleinsten Einheiten des Systems. Z.B. eine Klasse oder eine Component.</li>
            <li>Da wir alle Einheiten einzeln testen, können wir auf sehr detaillierter Ebene testen.</li>
            <li>Unit Tests haben üblicherweise eine kurze Laufzeit, da nicht eine vollständige Anwendung hochgefahren werden muss.</li>
            <li>Bei einem Frontend wird oft auch kein richtiger Browser verwendet, sondern ein "headless" Browser, der das HTML nicht rendered.</li>
            <li>Unit Tests sollten auch schnell laufen, da sie das schnellste Feedback beim Entwickeln geben.</li>
        </ul>
    </aside>
</section>
<section>
    <h4>Integration Tests</h4>
    <ul>
        <li>automatisierte Tests</li>
        <li>Testen zusammenhängender Teile der Anwendung
            <ul>
                <li>ein Backend Service (ohne Frontend)</li>
                <li>ein Frontend (ohne Backend)</li>
            </ul>
        </li>
        <li>weniger Detailtiefe</li>
        <li>Fokus liegt auf
            <ul>
                <li>wichtigen Szenarien</li>
                <li>interessanten Edge-Cases</li>
                <li>Fehlern die aufgetreten sind</li>
            </ul>
        </li>
        <li>etwas längere Laufzeit</li>
    </ul>
    <aside class="notes">
        <ul>
            <li>Meist wird der Code bei einem Integration-Test in einer Testumgebung getestet.</li>
            <li>Ein Backend oder ein Frontend wird hochgefahren, die Schnittstellen werden gemockt.</li>
            <li>Anschließend werden die Schnittstellen des Frontends/Backends maschinell angesprochen. Z.B. ein Bot, der eine Web API aufruft.</li>
            <li>Da es mehr Fälle geben kann, muss man sich auf wichtige Szenarien beschränken.</li>
            <li>Oft lohnt es sich merkwürdige Fehler, die aufgetreten sind, über einen Integration-Test zu testen, um den Fehler in Zukunft zu verhindern.</li>
            <li>Meist haben Integration-Tests eine höhere Laufzeit, da erst der Service oder das Frontend hochgefahren werden muss.</li>
        </ul>
    </aside>
</section>
<section>
    <h4>Manuelle/automatisierte End to End UI Tests</h4>
    <ul>
        <li>manuelle oder automatisierte Tests</li>
        <li>Testen über das richtige UI</li>
        <li>Testen der gesamten Software</li>
        <li>Styling erfordert manuelle Tests</li>
        <li>lange Laufzeit (besonders für einen Mensch)</li>
    </ul>
    <aside class="notes">
        <ul>
            <li>Test auf der realen Umgebung.</li>
            <li>Computer oder Mensch klickt sich durch die Anwendung und prüft, ob sie richtig funktioniert.</li>
            <li>Ein Computer kann nicht entscheiden, ob etwas gut oder schlecht aussieht. Daher kommt es beim Styling immer noch auf den Mensch an.</li>
            <li>Besonders bei manuellen Tests ist die Laufzeit sehr hoch, da ein Mensch nur begrenzt schnell klicken kann.</li>
            <li>Außerdem kann man Menschen nicht duplizieren und die Tests parallel ausführen.</li>
            <li>Aber auch für einen Bot dauert es länger das Frontend zu klicken, da immer auf eine richtige Antwort aus dem Backend gewartet werden muss und das Frontend neu rendern muss.</li>
        </ul>
    </aside>
</section>
<section>
    <h4>Wieso schreiben wir Unit Tests?</h4>
    <ul>
        <li>kleine Tests sind übersichtlicher</li>
        <li>test driven development
            <ul>
                <li>schnelles Feedback</li>
                <li>vermeidet Seiteneffekte</li>
            </ul>
        </li>
        <li>Components vielseitig einsetzbar</li>
        <li>lebende Dokumentation</li>
    </ul>
    <aside class="notes">
        <ul>
            <li>Kleine Tests sind wie kleine Components übersichtlicher. Daher sollten wir Unittesten.</li>
            <li>TDD bietet uns bei der Entwicklung schnelles Feedback und das Vermeiden von Seiteneffekten beim Anpassen von Features.</li>
            <li>Statt ein Feature jedes Mal manuell über die UI zu testen, kann man beim TDD einfach schnell die Tests ausführen.</li>
            <li>Components müssen eigenständig getestet sein, da sie auch eigenständig eingesetzt werden können.</li>
            <li>Tests können gut als lebende Dokumentation dienen.</li>
        </ul>
    </aside>
</section>
<section>
    <h4>Wie schreiben wir Unit Tests?</h4>
    <ul>
        <li>Component muss isoliert werden</li>
        <li>z.B. mit Dependency Injection</li>
        <li>Schnittstellen werden "gemockt"</li>
        <li>Childcomponents werden "gemockt"</li>
    </ul>
    <aside class="notes">
        <ul>
            <li>Über Dependency Injection können wir externe Abhängigkeiten einer Component mocken.</li>
            <li>Mocken heißt, dass wir die reale Implementierung gegen eine Testimplementierung (einen Mock) austauschen.</li>
            <li>Childcomponents können wir auch mocken, da diese ihren eigenen Unittest haben.</li>
            <li>Wir testen die Component nun über alle Schnittstellen. Was kommt rein, was geht raus. Später im Detail mehr.</li>
        </ul>
    </aside>
</section>
