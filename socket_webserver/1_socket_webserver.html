<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>1. Socket Webserver</title>

    <link rel="stylesheet" href="/dist/reset.css">
    <link rel="stylesheet" href="/dist/reveal.css">
    <link rel="stylesheet" href="/dist/theme/white.css">

    <link rel="stylesheet" href="/plugin/highlight/zenburn.css">
    <link rel="stylesheet" href="styles/custom_styles.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            <textarea data-template>
                #### HTTP - Hypertext Transfer Protokoll

                - Protokoll zur Übertragung von Daten über ein Netzwerk
                - Wird hauptsächlich im WWW eingesetzt

                <img src="assets/http_client_server.png" style="height: 400px;">
            </textarea>
        </section>
        <section>
            <section>
                <h4>HTTP - Request Response Prinzip</h4>
                <pre>
                <code class="language-plantuml">
                  @startuml
                  Client -> Server: Request (HTTP)
                  Server -> Client: Response (HTTP)
                  @enduml
                </code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Client schickt Daten zum Server</li>
                        <li>Server antwortet auf die Anfrage des Client</li>
                        <li>pre HTML 2 darf der Server keine Daten "pushen"</li>
                    </ul>
                </aside>
            </section>
            <section data-markdown>
            <textarea data-template>
                #### HTTP - Request Response Prinzip

                - Ab HTTP/2 darf der Server Daten "pushen"
                - Vorteile:
                    - kein unnötiger Request Cycle
                    - weniger Kommunikation und mehr Performance

                Notes:
                - https://hpbn.co/http2/
                - Beispiel:
                    - Nachladen von Stylesheets etc. bei einer Webanwendung können direkt vom Server gepusht werden, ohne dass der Client danach fragen muss.
            </textarea>
            </section>
            <section>
                <h4>HTTP - Request Response Prinzip</h4>
                <pre>
                    <code class="language-plantuml">
                      @startuml
                      Client -> Server: Request "Homepage"
                      Server -> Client: homepage.html
                      Server -> Client: stylesheet.css
                      Server -> Client: logic.js
                      @enduml
                    </code>
                </pre>
                <aside class="notes">
                    <ul>
                        <li>Client schickt Daten zum Server</li>
                        <li>Server antwortet auf die Anfrage des Client</li>
                        <li>pre HTML 2 darf der Server keine Daten "pushen"</li>
                    </ul>
                </aside>
            </section>
        </section>
        <section>
            <section>
                <div class="r-stack">
                    <div class="fragment fade-out" data-fragment-index="1">
                        <h4>HTTP/2 - Header Aufbau</h4>

                        <p>Pseudo-Header Fields:</p>
                        <ul>
                            <li>:method</li>
                            <li>:scheme</li>
                            <li>:authority</li>
                            <li>:path</li>
                        </ul>
                        <p>Header Fields:</p>
                        <pre class="fitted-code-wrapper"><code class="xml hljs">&lt;header-field&gt;: &lt;header-value&gt;</code></pre>
                        <p class="small-text">Bsp. Content-Type: appliation/json</p>
                    </div>
                    <img class="fragment" data-fragment-index="1" src="assets/http2_header_example.png" height="400">
                </div>

                <aside class="notes">
                    <ul>
                        <li>siehe: <a href="https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.1">Pseudo-Header
                            Fields</a></li>
                    </ul>
                </aside>
            </section>
            <section>
                <h4>HTTP/1.1 - Header Aufbau</h4>

                <p>Erste Zeile:</p>
                <pre class="fitted-code-wrapper"><code class="xml hljs">&lt;method&gt;&lt;uri&gt;&lt;protocol&gt;</code></pre>
                <p>Weitere Zeilen:</p>
                <pre class="fitted-code-wrapper"><code
                        class="xml hljs">&lt;header-field&gt;: &lt;header-value&gt;</code></pre>
                <p class="small-text">Bsp. Content-Type: appliation/json</p>

                <p>Letzte Zeile: Leerzeile</p>
            </section>
        </section>
        <section>
            <section data-markdown>
            <textarea data-template>
                #### HTTP - Header Method

                - GET - Ressource Anfordern
                - POST - Ressource anlegen (nicht Idempotent)
                - PUT - Ressource ersetzen
                - DELETE - Ressource löschen
            </textarea>
            </section>
            <section data-markdown>
            <textarea data-template>
                #### HTTP - Header Method
                - HEAD - Header zu einer Ressource Anfordern
                - PATCH - Ressource modifizieren (nicht Idempotent)
                - OPTIONS - Kommunikationsoptionen zu einer Ressource
                - CONNECT - Vorbereitung SSL-Tunnel im Proxy
                - TRACE - Gibt den Weg zum Server zurück (debugging)
            </textarea>
            </section>
        </section>
        <section>
            <section>
                <h4>HTTP - Header URI</h4>

                <p>Uniform Ressource Identifier</p>

                <p>Aufbau:</p>
                <pre class="fitted-code-wrapper">
                    <code class="xml hljs">&lt;schema&gt;://&lt;server&gt;&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;</code>
                </pre>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### URI - Schema

                    - Name des Schemas entspricht meist dem Übertragungsprotokoll
                    - Beispiele: HTTP, HTTPS, FTP, MAILTO, ...
                    - Für Webanwendungen hauptsächlich HTTPS
                    - Custom Schema URL

                    Notes:
                    - Custom Schema URL findet man im App Kontext, es sei aber nur erwähnt
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### URI - Server

                    - Fully-Qualified Host Name
                        - Fully-Qualified Domain Name (FQDN, z.B. www.dhbw.de)
                        - IP Adresse (z.B. 10.203.15.2)

                    Notes:
                    - Eine Eindeutige Bezeichnung des Rechners
                        - Entweder durch einen Domain Name
                        - Oder eine IP Adresse
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### URI - Port und Path

                    - Port:
                        - Ganze Zahl <= 65535
                        - falls nicht angegeben wird für HTTP: 80 und HTTPS: 443 angenommen

                    - Pfad:
                        - unterteilt mit '/'
                        - beliebige Zeichenkette mit einigen Ausnahmen
                        - Empfehlung:
                            - Alphanumeric Characters (A–Z, a–z, 0–9)
                            - Filename Safe Alphabet (A–Z, a–z, 0–9, -, _)
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### URI - Query

                    - optionale Parameter
                    - besteht aus Name und Wert (?x=6&name=Mueller&y=0)
                    - einige Sonderzeichen müssen encodiert werden
                </textarea>
            </section>
            <section>
                <h4>URI - Fragment</h4>

                <p>verweist auf ein Element der Zielseite</p>
                <p><a href="https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.1">/html/rfc7540<span
                        style="color: red">#section-8.1.2.1</span></a></p>
            </section>
            <section>
                <h4>URI - Kodierung</h4>

                <ul>
                    <li>Zeichen mit einer Sonderfunktion müssen encodiert werden</li>
                    <li>Beispiel:</li>
                </ul>

                <p>Url als QueryParameter?</p>
                <p><a href="https://datatracker.ietf.org/">https://datatracker.ietf.org/</a> <br> -> https%3A%2F%2Fdatatracker.ietf.org%2F</p>
            </section>
        </section>
        <section data-markdown>
            <textarea data-template>
                #### HTTP - Protokoll

                - normalerweise HTTP/2
                - HTTP/1.1 wird immer noch verwendet
                - HTTP/3 wird vereinzelt schon verwendet

                Notes:
                - HTTP/2 bringt einige gute Verbesserungen in Punkto Performance mit
                    - Multiplexing
                    - Server Push
                    - Compression
            </textarea>
        </section>
        <section data-markdown>
            <textarea data-template>
                #### HTTP - Header Felder

                - Accept
                    - erwarteter Media Type der Response
                - Content-Type (Content-Type: application/json)
                    - Media Type des Bodies
                - viele weitere Felder möglich

                Notes:
                - Googelt man, wenn man es braucht
            </textarea>
        </section>
        <section data-markdown>
            <textarea data-template>
                #### HTTP - Status Codes

                - 1xx Informational
                - 2xx Successful
                - 3xx Redirection
                - 4xx Client Error
                - 5xx Server Error

                - Status Codes mir sprechenden Fehlermeldungen versehen!
                - Außer dabei werden Sicherheitskritische Informationen freigegeben.

                Notes:
                - Vernünftige Status Codes mit sprechenden Fehlermeldungen helfen enorm beim Debugging.
                - Sicherheitskritische Informationen dürfen nicht nach außen gegeben werden.
                - Evtl. arbeitet man hier mit einem Debug Mode des Servers, in dem er mehr Informationen ausgibt.
            </textarea>
        </section>
        <section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Webserver Marke Eigenbau

                    - Ziel
                        - Ein kleiner Webserver, der Anfragen eines Clients beantworten kann.

                    - Form
                        - Java - Konsolen - Anwendung
                        - Port öffnen
                        - Verbindung entgegennehmen
                        - Anfrage beantworten
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Webclient

                    - Über Java eine Socket-Verbindung aufbauen
                    - Anfrage an einen beliebigen Server senden (z.B. www.xkcd.com, HTTP/1.1)
                    - Response auf die Konsole ausgeben

                    - Auslesen der Antwort
                        - Header und Body unterscheiden
                        - Auslesen des Status-Code
                        - Auslesen der Felder Content-Length, Content-Type und Connection
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Webserver

                    - Step 1
                        - Mit Java einen Webserver bereitstellen
                            - Dieser soll eine Socket Connection bereitstellen und eine Anfrage bearbeiten
                        - Wir schreiben uns einen Client, der diesen Webserver aufruft
                    - Step 2
                        - Webserver soll jetzt mehrere Requests bearbeiten können
                    - Step 3
                        - Webserver soll jetzt mit mehreren Clients sprechen können
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Werkzeug Client

                    Client öffnet Port:
                    ```java
                    Socket socket = new Socket(server, 80);
                    ```
                    Client schließt Port
                    ```java
                    socket.close();
                    ```
                    Empfangen von Daten:
                    ```java
                    InputStream in = socket.getInputStream();
                    int c = in.read();
                    ```
                    Senden von Daten:
                    ```java
                    OutputStream out = socket.getOutputStream();
                    out.write(c);
                    ```
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Werkzeug Server

                    Server öffnet einen Port (Server Socket):
                    ```java
                    ServerSocket serverSocket = new ServerSocket(port);
                    ```
                    Server wartet auf eine Verbindung (hier wird das eigentliche Socket initialisiert):
                    ```java
                    Socket socket = serverSocket.accept();
                    ```
                    Server schließt eine Verbindung:
                    ```java
                    socket.close();
                    ```
                    Server schließt den Port
                    ```java
                    serverSocket.close();
                    ```
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - Kleine Erinnerung

                    Zeilenweise Empfangen von Daten
                    ```java
                    var in = new BufferedReader(
                        new InputStreamReader(
                            clientSocket.getInputStream()
                        )
                    );
                    String line = in.readLine();
                    ```
                    Zeilenweise Senden von Daten
                    ```java
                    var out = new PrintWriter(
                        socket.getOutputStream, true
                    );
                    out.println("Hello World");
                    ```
                </textarea>
            </section>
            <section data-markdown>
                <textarea data-template>
                    #### Praxis - SSL Verbindung

                    SSL-Verbindung für HTTPS:
                    ```java
                    var sslSocketFactory = SSLSocketFactory.getDefault();
                    Socket sslSocket = sslSocketFactory.createSocket(host, port);
                    ```
                </textarea>
            </section>
        </section>
    </div>
</div>

<script src="/dist/reveal.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        dependencies: [
            {src: '//cdn.jsdelivr.net/npm/reveal-plantuml'},
        ]
    });
</script>
</body>
</html>
